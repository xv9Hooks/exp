--[[
    Decompiler Override System
    Executor'ın decompiler'ını kendi yazdiginla degistirir
]]

local DecompilerOverride = {}

-- Orijinalleri sakla
local Originals = {
    decompile = decompile,
    getscriptbytecode = getscriptbytecode,
}

-- ========================
-- KENDI DECOMPILER'IN
-- ========================

local BytecodeReader = {}
BytecodeReader.__index = BytecodeReader

function BytecodeReader.new(data)
    return setmetatable({data = data, pos = 1}, BytecodeReader)
end

function BytecodeReader:ReadByte()
    local b = string.byte(self.data, self.pos) or 0
    self.pos = self.pos + 1
    return b
end

function BytecodeReader:ReadUInt32()
    local a, b, c, d = string.byte(self.data, self.pos, self.pos + 3)
    self.pos = self.pos + 4
    return (a or 0) + ((b or 0) * 256) + ((c or 0) * 65536) + ((d or 0) * 16777216)
end

function BytecodeReader:ReadVarInt()
    local result, shift = 0, 0
    repeat
        local byte = self:ReadByte()
        result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
        shift = shift + 7
    until bit32.band(byte, 0x80) == 0
    return result
end

function BytecodeReader:ReadString()
    local len = self:ReadVarInt()
    if len == 0 then return "" end
    local str = self.data:sub(self.pos, self.pos + len - 1)
    self.pos = self.pos + len
    return str
end

function BytecodeReader:ReadDouble()
    local bytes = {}
    for i = 1, 8 do bytes[i] = self:ReadByte() end
    local sign = bit32.rshift(bytes[8], 7)
    local exp = bit32.lshift(bit32.band(bytes[8], 0x7F), 4) + bit32.rshift(bytes[7], 4)
    if exp == 0 then return 0 end
    local mantissa = bit32.band(bytes[7], 0x0F)
    for i = 6, 1, -1 do mantissa = mantissa * 256 + bytes[i] end
    local val = (1 + mantissa / 4503599627370496) * (2 ^ (exp - 1023))
    return sign == 1 and -val or val
end

-- Opcode tablosu
local OP = {
    [0]="NOP",[2]="LOADNIL",[3]="LOADB",[4]="LOADN",[5]="LOADK",
    [6]="MOVE",[7]="GETGLOBAL",[8]="SETGLOBAL",[9]="GETUPVAL",[10]="SETUPVAL",
    [12]="GETIMPORT",[13]="GETTABLE",[14]="SETTABLE",[15]="GETTABLEKS",
    [16]="SETTABLEKS",[19]="NEWCLOSURE",[20]="NAMECALL",[21]="CALL",
    [22]="RETURN",[23]="JUMP",[25]="JUMPIF",[26]="JUMPIFNOT",
    [33]="ADD",[34]="SUB",[35]="MUL",[36]="DIV",[49]="CONCAT",
    [50]="NOT",[51]="MINUS",[52]="LENGTH",[53]="NEWTABLE",
    [56]="FORNPREP",[57]="FORNLOOP",[58]="FORGLOOP",[63]="GETVARARGS",
}

-- Ana Decompiler
local Decompiler = {}

function Decompiler:Parse(bytecode)
    local r = BytecodeReader.new(bytecode)
    
    local version = r:ReadByte()
    if version == 0 then return nil, "Compile error in bytecode" end
    
    -- Strings
    local strCount = r:ReadVarInt()
    local strings = {}
    for i = 1, strCount do strings[i] = r:ReadString() end
    
    -- Protos
    local protoCount = r:ReadVarInt()
    local protos = {}
    
    for i = 1, protoCount do
        local proto = {
            maxStack = r:ReadByte(),
            numParams = r:ReadByte(),
            numUpvals = r:ReadByte(),
            isVararg = r:ReadByte(),
            flags = r:ReadByte(),
        }
        
        -- Type info skip
        local typeSize = r:ReadVarInt()
        for j = 1, typeSize do r:ReadByte() end
        
        -- Code
        local codeSize = r:ReadVarInt()
        proto.code = {}
        for j = 1, codeSize do proto.code[j] = r:ReadUInt32() end
        
        -- Constants
        local kSize = r:ReadVarInt()
        proto.constants = {}
        for j = 1, kSize do
            local t = r:ReadByte()
            if t == 0 then proto.constants[j] = {t="nil"}
            elseif t == 1 then proto.constants[j] = {t="bool", v=r:ReadByte()~=0}
            elseif t == 2 then proto.constants[j] = {t="num", v=r:ReadDouble()}
            elseif t == 3 then proto.constants[j] = {t="str", v=strings[r:ReadVarInt()]}
            elseif t == 4 then proto.constants[j] = {t="imp", v=r:ReadUInt32()}
            elseif t == 5 then
                local n = r:ReadVarInt()
                for k = 1, n do r:ReadVarInt() end
                proto.constants[j] = {t="tbl"}
            elseif t == 6 then proto.constants[j] = {t="cls", v=r:ReadVarInt()}
            end
        end
        
        -- Child protos
        local pSize = r:ReadVarInt()
        for j = 1, pSize do r:ReadVarInt() end
        
        -- Debug
        proto.line = r:ReadVarInt()
        local nameIdx = r:ReadVarInt()
        proto.name = strings[nameIdx] or "func"
        
        -- Skip line info
        if r:ReadByte() ~= 0 then
            local intervals = math.floor((codeSize-1)/4)+1
            for j = 1, codeSize do r:ReadByte() end
            for j = 1, intervals do r:ReadUInt32() end
        end
        
        -- Skip debug info
        if r:ReadByte() ~= 0 then
            local lc = r:ReadVarInt()
            for j = 1, lc do r:ReadVarInt();r:ReadVarInt();r:ReadVarInt();r:ReadByte() end
            local uc = r:ReadVarInt()
            for j = 1, uc do r:ReadVarInt() end
        end
        
        protos[i] = proto
    end
    
    local mainIdx = r:ReadVarInt()
    return {v=version, strings=strings, protos=protos, main=mainIdx}
end

function Decompiler:GetK(proto, idx)
    local k = proto.constants[idx+1]
    if not k then return "nil" end
    if k.t=="nil" then return "nil"
    elseif k.t=="bool" then return tostring(k.v)
    elseif k.t=="num" then return k.v==math.floor(k.v) and tostring(math.floor(k.v)) or tostring(k.v)
    elseif k.t=="str" then return string.format("%q", k.v)
    else return "nil" end
end

function Decompiler:DecompileProto(data, pIdx)
    local proto = data.protos[pIdx+1]
    if not proto then return "-- invalid proto" end
    
    local out = {}
    local indent = 0
    local function emit(s) out[#out+1] = string.rep("    ",indent)..s end
    local function R(n) return "v"..n end
    local function K(n) return self:GetK(proto,n) end
    
    -- Header
    local params = {}
    for i=0,proto.numParams-1 do params[#params+1]="a"..i end
    if proto.isVararg>0 then params[#params+1]="..." end
    emit("function "..(proto.name or "func").."("..table.concat(params,", ")..")")
    indent = indent + 1
    
    local i = 1
    while i <= #proto.code do
        local inst = proto.code[i]
        local op = bit32.band(inst, 0xFF)
        local A = bit32.band(bit32.rshift(inst,8), 0xFF)
        local B = bit32.band(bit32.rshift(inst,16), 0xFF)
        local C = bit32.band(bit32.rshift(inst,24), 0xFF)
        local D = bit32.band(bit32.rshift(inst,16), 0xFFFF)
        local sD = D>32767 and D-65536 or D
        local opname = OP[op] or "UNK"
        
        if opname=="LOADNIL" then emit(R(A).." = nil")
        elseif opname=="LOADB" then emit(R(A).." = "..(B==1 and "true" or "false"))
        elseif opname=="LOADN" then emit(R(A).." = "..sD)
        elseif opname=="LOADK" then emit(R(A).." = "..K(D))
        elseif opname=="MOVE" then emit(R(A).." = "..R(B))
        elseif opname=="GETGLOBAL" then
            local aux = proto.code[i+1] or 0
            emit(R(A).." = "..K(bit32.band(aux,0xFFFFFF)))
            i=i+1
        elseif opname=="SETGLOBAL" then
            local aux = proto.code[i+1] or 0
            emit(K(bit32.band(aux,0xFFFFFF)).." = "..R(A))
            i=i+1
        elseif opname=="GETTABLEKS" then emit(R(A).." = "..R(B).."["..K(C).."]")
        elseif opname=="SETTABLEKS" then emit(R(B).."["..K(C).."] = "..R(A))
        elseif opname=="GETTABLE" then emit(R(A).." = "..R(B).."["..R(C).."]")
        elseif opname=="SETTABLE" then emit(R(B).."["..R(C).."] = "..R(A))
        elseif opname=="NAMECALL" then
            emit("-- "..R(A).." = "..R(B)..":"..K(C))
            i=i+1
        elseif opname=="CALL" then
            local args={}
            for j=1,B-1 do args[#args+1]=R(A+j) end
            emit(R(A).."("..table.concat(args,", ")..")")
        elseif opname=="RETURN" then
            if B<=1 then emit("return")
            else
                local rets={}
                for j=0,B-2 do rets[#rets+1]=R(A+j) end
                emit("return "..table.concat(rets,", "))
            end
        elseif opname=="ADD" then emit(R(A).." = "..R(B).." + "..R(C))
        elseif opname=="SUB" then emit(R(A).." = "..R(B).." - "..R(C))
        elseif opname=="MUL" then emit(R(A).." = "..R(B).." * "..R(C))
        elseif opname=="DIV" then emit(R(A).." = "..R(B).." / "..R(C))
        elseif opname=="CONCAT" then
            local p={}
            for j=B,C do p[#p+1]=R(j) end
            emit(R(A).." = "..table.concat(p," .. "))
        elseif opname=="NOT" then emit(R(A).." = not "..R(B))
        elseif opname=="MINUS" then emit(R(A).." = -"..R(B))
        elseif opname=="LENGTH" then emit(R(A).." = #"..R(B))
        elseif opname=="NEWTABLE" then emit(R(A).." = {}")
        elseif opname=="JUMP" then emit("-- jump "..sD)
        elseif opname=="JUMPIF" then emit("if "..R(A).." then")
        elseif opname=="JUMPIFNOT" then emit("if not "..R(A).." then")
        elseif opname=="FORNPREP" then emit("for "..R(A+3).." = "..R(A)..", "..R(A+1)..", "..R(A+2).." do"); indent=indent+1
        elseif opname=="FORNLOOP" then indent=indent-1; emit("end")
        elseif opname=="GETVARARGS" then emit(R(A).." = ...")
        elseif opname=="NEWCLOSURE" then emit(R(A).." = function() end")
        elseif opname=="GETIMPORT" then
            local aux = proto.code[i+1] or 0
            emit(R(A).." = import("..aux..")")
            i=i+1
        else emit("-- "..opname.." "..A.." "..B.." "..C)
        end
        i=i+1
    end
    
    indent=indent-1
    emit("end")
    return table.concat(out,"\n")
end

function Decompiler:Decompile(bytecode)
    local data, err = self:Parse(bytecode)
    if not data then return "-- Error: "..tostring(err) end
    
    local header = "-- Luau Bytecode v"..data.v.."\n-- Custom Decompiler\n\n"
    return header .. self:DecompileProto(data, data.main)
end

-- ========================
-- OVERRIDE FONKSIYONLARI
-- ========================

function DecompilerOverride:Enable()
    -- decompile'ı override et
    getgenv().decompile = function(scriptInstance)
        -- Script kontrolü
        if typeof(scriptInstance) ~= "Instance" then
            return "-- Invalid argument: expected script instance"
        end
        
        if not scriptInstance:IsA("LuaSourceContainer") then
            return "-- Not a script"
        end
        
        -- Bytecode al
        local bytecode
        if Originals.getscriptbytecode then
            local ok, bc = pcall(Originals.getscriptbytecode, scriptInstance)
            if ok then bytecode = bc end
        end
        
        if not bytecode or #bytecode == 0 then
            return "-- Cannot get bytecode\n-- Script: " .. scriptInstance:GetFullName()
        end
        
        -- Kendi decompiler'ımızla decompile et
        return Decompiler:Decompile(bytecode)
    end
    
    print("[DecompilerOverride] Enabled - Using custom decompiler")
end

function DecompilerOverride:Disable()
    -- Orijinale geri dön
    getgenv().decompile = Originals.decompile
    print("[DecompilerOverride] Disabled - Using original decompiler")
end

function DecompilerOverride:Toggle()
    if getgenv().decompile == Originals.decompile then
        self:Enable()
    else
        self:Disable()
    end
end

-- ========================
-- AUTO ENABLE
-- ========================
DecompilerOverride:Enable()

return DecompilerOverride
