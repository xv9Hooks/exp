--[[
    Custom Luau Decompiler v2
    Luau Bytecode Version 3-6 Destekli
]]

--// ==================== BYTECODE READER ====================
local BytecodeReader = {}
BytecodeReader.__index = BytecodeReader

function BytecodeReader.new(bytecode)
    local self = setmetatable({}, BytecodeReader)
    self.bytecode = bytecode
    self.position = 1
    self.length = #bytecode
    return self
end

function BytecodeReader:ReadByte()
    if self.position > self.length then return 0 end
    local byte = string.byte(self.bytecode, self.position)
    self.position = self.position + 1
    return byte
end

function BytecodeReader:ReadUInt32()
    local b1, b2, b3, b4 = self:ReadByte(), self:ReadByte(), self:ReadByte(), self:ReadByte()
    return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000)
end

function BytecodeReader:ReadInt32()
    local value = self:ReadUInt32()
    if value >= 0x80000000 then
        value = value - 0x100000000
    end
    return value
end

function BytecodeReader:ReadFloat()
    local b = {self:ReadByte(), self:ReadByte(), self:ReadByte(), self:ReadByte()}
    local sign = (b[4] >= 128) and -1 or 1
    local exp = ((b[4] % 128) * 2) + math.floor(b[3] / 128)
    local mantissa = ((b[3] % 128) * 0x10000) + (b[2] * 0x100) + b[1]
    
    if exp == 0 and mantissa == 0 then return 0 end
    if exp == 255 then return (mantissa == 0) and (sign * math.huge) or (0/0) end
    
    return sign * math.ldexp(1 + mantissa / 0x800000, exp - 127)
end

function BytecodeReader:ReadDouble()
    local b = {}
    for i = 1, 8 do b[i] = self:ReadByte() end
    
    local sign = (b[8] >= 128) and -1 or 1
    local exp = ((b[8] % 128) * 16) + math.floor(b[7] / 16)
    local mantissa = (b[7] % 16)
    
    for i = 6, 1, -1 do
        mantissa = mantissa * 256 + b[i]
    end
    
    if exp == 0 and mantissa == 0 then return 0 end
    if exp == 2047 then return (mantissa == 0) and (sign * math.huge) or (0/0) end
    
    return sign * math.ldexp(1 + mantissa / 0x10000000000000, exp - 1023)
end

function BytecodeReader:ReadVarInt()
    local result, shift = 0, 0
    local byte
    repeat
        byte = self:ReadByte()
        result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
        shift = shift + 7
    until bit32.band(byte, 0x80) == 0
    return result
end

function BytecodeReader:ReadString()
    local length = self:ReadVarInt()
    if length == 0 then return "" end
    local str = string.sub(self.bytecode, self.position, self.position + length - 1)
    self.position = self.position + length
    return str
end

function BytecodeReader:ReadBytes(count)
    local bytes = {}
    for i = 1, count do bytes[i] = self:ReadByte() end
    return bytes
end

function BytecodeReader:Skip(count)
    self.position = self.position + count
end

--// ==================== OPCODE TANIMLARI ====================
local OpcodeNames = {
    [0] = "NOP", [1] = "BREAK", [2] = "LOADNIL", [3] = "LOADB", [4] = "LOADN",
    [5] = "LOADK", [6] = "MOVE", [7] = "GETGLOBAL", [8] = "SETGLOBAL",
    [9] = "GETUPVAL", [10] = "SETUPVAL", [11] = "CLOSEUPVALS", [12] = "GETIMPORT",
    [13] = "GETTABLE", [14] = "SETTABLE", [15] = "GETTABLEKS", [16] = "SETTABLEKS",
    [17] = "GETTABLEN", [18] = "SETTABLEN", [19] = "NEWCLOSURE", [20] = "NAMECALL",
    [21] = "CALL", [22] = "RETURN", [23] = "JUMP", [24] = "JUMPBACK",
    [25] = "JUMPIF", [26] = "JUMPIFNOT", [27] = "JUMPIFEQ", [28] = "JUMPIFLE",
    [29] = "JUMPIFLT", [30] = "JUMPIFNOTEQ", [31] = "JUMPIFNOTLE", [32] = "JUMPIFNOTLT",
    [33] = "ADD", [34] = "SUB", [35] = "MUL", [36] = "DIV", [37] = "MOD",
    [38] = "POW", [39] = "ADDK", [40] = "SUBK", [41] = "MULK", [42] = "DIVK",
    [43] = "MODK", [44] = "POWK", [45] = "AND", [46] = "OR", [47] = "ANDK",
    [48] = "ORK", [49] = "CONCAT", [50] = "NOT", [51] = "MINUS", [52] = "LENGTH",
    [53] = "NEWTABLE", [54] = "DUPTABLE", [55] = "SETLIST", [56] = "FORNPREP",
    [57] = "FORNLOOP", [58] = "FORGLOOP", [59] = "FORGPREP_INEXT", [60] = "FORGLOOP_INEXT",
    [61] = "FORGPREP_NEXT", [62] = "FORGLOOP_NEXT", [63] = "GETVARARGS", [64] = "DUPCLOSURE",
    [65] = "PREPVARARGS", [66] = "LOADKX", [67] = "JUMPX", [68] = "FASTCALL",
    [69] = "COVERAGE", [70] = "CAPTURE", [71] = "JUMPIFEQK", [72] = "JUMPIFNOTEQK",
    [73] = "FASTCALL1", [74] = "FASTCALL2", [75] = "FASTCALL2K", [76] = "FORGPREP",
    [77] = "JUMPXEQKNIL", [78] = "JUMPXEQKB", [79] = "JUMPXEQKN", [80] = "JUMPXEQKS",
    [81] = "IDIV", [82] = "IDIVK", [83] = "SUBRK", [84] = "DIVRK"
}

--// ==================== INSTRUCTION DECODER ====================
local function DecodeInstruction(raw)
    local opcode = bit32.band(raw, 0xFF)
    local A = bit32.band(bit32.rshift(raw, 8), 0xFF)
    local B = bit32.band(bit32.rshift(raw, 16), 0xFF)
    local C = bit32.band(bit32.rshift(raw, 24), 0xFF)
    local D = bit32.band(bit32.rshift(raw, 16), 0xFFFF)
    
    if D >= 0x8000 then D = D - 0x10000 end
    
    return {
        raw = raw,
        opcode = opcode,
        opname = OpcodeNames[opcode] or ("OP_" .. opcode),
        A = A, B = B, C = C, D = D,
        Bx = B + C * 256
    }
end

--// ==================== PROTO PARSER (VERSÄ°YON 6 DESTEKLÄ°) ====================
local function ParseProto(reader, version, stringTable)
    local proto = {}
    
    proto.maxStackSize = reader:ReadByte()
    proto.numParams = reader:ReadByte()
    proto.numUpvalues = reader:ReadByte()
    proto.isVararg = reader:ReadByte() ~= 0
    
    -- Version 6+ iÃ§in flags
    if version >= 4 then
        proto.flags = reader:ReadByte()
    end
    
    -- Version 6+ iÃ§in typeinfo
    if version >= 4 then
        local typeinfoSize = reader:ReadVarInt()
        if typeinfoSize > 0 then
            reader:Skip(typeinfoSize)
        end
    end
    
    -- Instructions
    local instrCount = reader:ReadVarInt()
    proto.instructions = {}
    proto.auxValues = {}
    
    local i = 1
    while i <= instrCount do
        local raw = reader:ReadUInt32()
        local instr = DecodeInstruction(raw)
        proto.instructions[i] = instr
        
        -- BazÄ± opcode'lar aux value kullanÄ±r
        local op = instr.opcode
        if op == 12 or op == 20 or op == 27 or op == 28 or op == 29 or 
           op == 30 or op == 31 or op == 32 or op == 71 or op == 72 or
           op == 77 or op == 78 or op == 79 or op == 80 then
            i = i + 1
            if i <= instrCount then
                proto.auxValues[i - 1] = reader:ReadUInt32()
            end
        end
        
        i = i + 1
    end
    
    -- Constants
    local constCount = reader:ReadVarInt()
    proto.constants = {}
    
    for i = 1, constCount do
        local constType = reader:ReadByte()
        
        if constType == 0 then -- Nil
            proto.constants[i] = {type = "nil", value = nil}
        elseif constType == 1 then -- Boolean
            proto.constants[i] = {type = "boolean", value = reader:ReadByte() ~= 0}
        elseif constType == 2 then -- Number
            proto.constants[i] = {type = "number", value = reader:ReadDouble()}
        elseif constType == 3 then -- String (index to string table)
            local strIndex = reader:ReadVarInt()
            local str = stringTable[strIndex] or ("string_" .. strIndex)
            proto.constants[i] = {type = "string", value = str}
        elseif constType == 4 then -- Import
            proto.constants[i] = {type = "import", value = reader:ReadUInt32()}
        elseif constType == 5 then -- Table
            local tableSize = reader:ReadVarInt()
            local keys = {}
            for j = 1, tableSize do
                keys[j] = reader:ReadVarInt()
            end
            proto.constants[i] = {type = "table", value = keys}
        elseif constType == 6 then -- Closure
            proto.constants[i] = {type = "closure", value = reader:ReadVarInt()}
        elseif constType == 7 then -- Vector (version 6+)
            local x = reader:ReadFloat()
            local y = reader:ReadFloat()
            local z = reader:ReadFloat()
            local w = reader:ReadFloat()
            proto.constants[i] = {type = "vector", value = {x, y, z, w}}
        else
            proto.constants[i] = {type = "unknown_" .. constType, value = nil}
        end
    end
    
    -- Child protos
    local childCount = reader:ReadVarInt()
    proto.childProtos = {}
    for i = 1, childCount do
        proto.childProtos[i] = reader:ReadVarInt()
    end
    
    -- Line defined
    proto.lineDefined = reader:ReadVarInt()
    
    -- Debug name
    proto.debugName = reader:ReadVarInt()
    
    -- Line info (optional)
    local hasLineInfo = reader:ReadByte() ~= 0
    if hasLineInfo then
        local lineGapLog2 = reader:ReadByte()
        local intervals = math.max(1, bit32.rshift(#proto.instructions - 1, lineGapLog2) + 1)
        
        -- Line offsets
        for i = 1, #proto.instructions do
            reader:ReadByte()
        end
        
        -- Absolute line info
        for i = 1, intervals do
            reader:ReadInt32()
        end
    end
    
    -- Debug info (optional)
    local hasDebugInfo = reader:ReadByte() ~= 0
    if hasDebugInfo then
        -- Local variables
        local localCount = reader:ReadVarInt()
        proto.locals = {}
        for i = 1, localCount do
            proto.locals[i] = {
                name = reader:ReadVarInt(),
                startPc = reader:ReadVarInt(),
                endPc = reader:ReadVarInt(),
                reg = reader:ReadByte()
            }
        end
        
        -- Upvalue names
        local upvalCount = reader:ReadVarInt()
        proto.upvalueNames = {}
        for i = 1, upvalCount do
            proto.upvalueNames[i] = reader:ReadVarInt()
        end
    end
    
    return proto
end

--// ==================== ANA DECOMPILER ====================
local Decompiler = {}
Decompiler.__index = Decompiler

function Decompiler.new()
    local self = setmetatable({}, Decompiler)
    self.version = 0
    self.strings = {}
    self.protos = {}
    self.output = {}
    self.indent = 0
    return self
end

function Decompiler:AddLine(text)
    table.insert(self.output, string.rep("    ", self.indent) .. text)
end

function Decompiler:GetString(index)
    return self.strings[index] or ("str_" .. index)
end

function Decompiler:GetConstant(proto, index)
    local const = proto.constants[index + 1]
    if not const then return "nil" end
    
    if const.type == "nil" then
        return "nil"
    elseif const.type == "boolean" then
        return const.value and "true" or "false"
    elseif const.type == "number" then
        local num = const.value
        if num == math.huge then return "math.huge" end
        if num == -math.huge then return "-math.huge" end
        if num ~= num then return "0/0" end -- NaN
        if num == math.floor(num) then
            return string.format("%d", num)
        end
        return tostring(num)
    elseif const.type == "string" then
        local s = const.value
        s = s:gsub('\\', '\\\\')
        s = s:gsub('"', '\\"')
        s = s:gsub('\n', '\\n')
        s = s:gsub('\r', '\\r')
        s = s:gsub('\t', '\\t')
        s = s:gsub('[%c]', function(c)
            return string.format('\\%03d', string.byte(c))
        end)
        return '"' .. s .. '"'
    elseif const.type == "vector" then
        local v = const.value
        return string.format("Vector3.new(%s, %s, %s)", v[1], v[2], v[3])
    elseif const.type == "import" then
        return self:DecodeImport(const.value)
    else
        return "nil --[[" .. const.type .. "]]"
    end
end

function Decompiler:DecodeImport(value)
    -- Import format: index1 | (index2 << 10) | (index3 << 20) | (count << 30)
    local count = bit32.rshift(value, 30)
    local idx1 = bit32.band(value, 0x3FF)
    local idx2 = bit32.band(bit32.rshift(value, 10), 0x3FF)
    local idx3 = bit32.band(bit32.rshift(value, 20), 0x3FF)
    
    local result = self:GetString(idx1)
    
    if count >= 2 then
        result = result .. "." .. self:GetString(idx2)
    end
    if count >= 3 then
        result = result .. "." .. self:GetString(idx3)
    end
    
    return result
end

function Decompiler:DecompileInstruction(proto, instr, pc)
    local op = instr.opname
    local A, B, C, D = instr.A, instr.B, instr.C, instr.D
    local aux = proto.auxValues[pc]
    
    if op == "NOP" or op == "BREAK" or op == "COVERAGE" then
        return nil
        
    elseif op == "LOADNIL" then
        return string.format("local v%d = nil", A)
        
    elseif op == "LOADB" then
        return string.format("local v%d = %s", A, B == 1 and "true" or "false")
        
    elseif op == "LOADN" then
        return string.format("local v%d = %d", A, D)
        
    elseif op == "LOADK" then
        return string.format("local v%d = %s", A, self:GetConstant(proto, D))
        
    elseif op == "MOVE" then
        return string.format("v%d = v%d", A, B)
        
    elseif op == "GETGLOBAL" then
        local name = self:GetConstant(proto, aux or 0):gsub('"', '')
        return string.format("local v%d = %s", A, name)
        
    elseif op == "SETGLOBAL" then
        local name = self:GetConstant(proto, aux or 0):gsub('"', '')
        return string.format("%s = v%d", name, A)
        
    elseif op == "GETUPVAL" then
        return string.format("local v%d = upval_%d", A, B)
        
    elseif op == "SETUPVAL" then
        return string.format("upval_%d = v%d", B, A)
        
    elseif op == "GETTABLE" then
        return string.format("v%d = v%d[v%d]", A, B, C)
        
    elseif op == "SETTABLE" then
        return string.format("v%d[v%d] = v%d", B, C, A)
        
    elseif op == "GETTABLEKS" then
        local key = self:GetConstant(proto, aux or C)
        if key:sub(1, 1) == '"' then
            local keyName = key:sub(2, -2)
            if keyName:match("^[%a_][%w_]*$") then
                return string.format("v%d = v%d.%s", A, B, keyName)
            end
        end
        return string.format("v%d = v%d[%s]", A, B, key)
        
    elseif op == "SETTABLEKS" then
        local key = self:GetConstant(proto, aux or C)
        if key:sub(1, 1) == '"' then
            local keyName = key:sub(2, -2)
            if keyName:match("^[%a_][%w_]*$") then
                return string.format("v%d.%s = v%d", B, keyName, A)
            end
        end
        return string.format("v%d[%s] = v%d", B, key, A)
        
    elseif op == "GETTABLEN" then
        return string.format("v%d = v%d[%d]", A, B, C + 1)
        
    elseif op == "SETTABLEN" then
        return string.format("v%d[%d] = v%d", B, C + 1, A)
        
    elseif op == "NEWTABLE" then
        return string.format("local v%d = {}", A)
        
    elseif op == "DUPTABLE" then
        return string.format("local v%d = {} -- duptable", A)
        
    elseif op == "GETIMPORT" then
        local importStr = self:DecodeImport(aux or D)
        return string.format("local v%d = %s", A, importStr)
        
    elseif op == "ADD" then return string.format("v%d = v%d + v%d", A, B, C)
    elseif op == "SUB" then return string.format("v%d = v%d - v%d", A, B, C)
    elseif op == "MUL" then return string.format("v%d = v%d * v%d", A, B, C)
    elseif op == "DIV" then return string.format("v%d = v%d / v%d", A, B, C)
    elseif op == "MOD" then return string.format("v%d = v%d %% v%d", A, B, C)
    elseif op == "POW" then return string.format("v%d = v%d ^ v%d", A, B, C)
    elseif op == "IDIV" then return string.format("v%d = v%d // v%d", A, B, C)
        
    elseif op == "ADDK" then return string.format("v%d = v%d + %s", A, B, self:GetConstant(proto, C))
    elseif op == "SUBK" then return string.format("v%d = v%d - %s", A, B, self:GetConstant(proto, C))
    elseif op == "MULK" then return string.format("v%d = v%d * %s", A, B, self:GetConstant(proto, C))
    elseif op == "DIVK" then return string.format("v%d = v%d / %s", A, B, self:GetConstant(proto, C))
    elseif op == "MODK" then return string.format("v%d = v%d %% %s", A, B, self:GetConstant(proto, C))
    elseif op == "POWK" then return string.format("v%d = v%d ^ %s", A, B, self:GetConstant(proto, C))
    elseif op == "IDIVK" then return string.format("v%d = v%d // %s", A, B, self:GetConstant(proto, C))
        
    elseif op == "SUBRK" then return string.format("v%d = %s - v%d", A, self:GetConstant(proto, B), C)
    elseif op == "DIVRK" then return string.format("v%d = %s / v%d", A, self:GetConstant(proto, B), C)
        
    elseif op == "AND" then return string.format("v%d = v%d and v%d", A, B, C)
    elseif op == "OR" then return string.format("v%d = v%d or v%d", A, B, C)
    elseif op == "ANDK" then return string.format("v%d = v%d and %s", A, B, self:GetConstant(proto, C))
    elseif op == "ORK" then return string.format("v%d = v%d or %s", A, B, self:GetConstant(proto, C))
        
    elseif op == "CONCAT" then
        local parts = {}
        for r = B, C do table.insert(parts, "v" .. r) end
        return string.format("v%d = %s", A, table.concat(parts, " .. "))
        
    elseif op == "NOT" then return string.format("v%d = not v%d", A, B)
    elseif op == "MINUS" then return string.format("v%d = -v%d", A, B)
    elseif op == "LENGTH" then return string.format("v%d = #v%d", A, B)
        
    elseif op == "NAMECALL" then
        local method = self:GetConstant(proto, aux or C)
        if method:sub(1, 1) == '"' then
            method = method:sub(2, -2)
        end
        return string.format("v%d = v%d -- :namecall(%s)", A, B, method)
        
    elseif op == "CALL" then
        local args = {}
        if B == 0 then
            table.insert(args, "...")
        elseif B > 1 then
            for r = A + 1, A + B - 1 do
                table.insert(args, "v" .. r)
            end
        end
        
        if C == 1 then
            return string.format("v%d(%s)", A, table.concat(args, ", "))
        elseif C == 0 then
            return string.format("v%d, ... = v%d(%s)", A, A, table.concat(args, ", "))
        else
            local rets = {}
            for r = A, A + C - 2 do
                table.insert(rets, "v" .. r)
            end
            return string.format("%s = v%d(%s)", table.concat(rets, ", "), A, table.concat(args, ", "))
        end
        
    elseif op == "RETURN" then
        if B == 1 then
            return "return"
        elseif B == 0 then
            return "return ..."
        else
            local rets = {}
            for r = A, A + B - 2 do
                table.insert(rets, "v" .. r)
            end
            return "return " .. table.concat(rets, ", ")
        end
        
    elseif op == "JUMP" then
        return string.format("-- jump %+d -> [%d]", D, pc + D + 1)
        
    elseif op == "JUMPBACK" then
        return string.format("-- jumpback %+d -> [%d]", D, pc + D + 1)
        
    elseif op == "JUMPX" then
        local E = bit32.band(bit32.rshift(instr.raw, 8), 0xFFFFFF)
        if E >= 0x800000 then E = E - 0x1000000 end
        return string.format("-- jumpx %+d", E)
        
    elseif op == "JUMPIF" then
        return string.format("if v%d then -- jump %+d", A, D)
        
    elseif op == "JUMPIFNOT" then
        return string.format("if not v%d then -- jump %+d", A, D)
        
    elseif op == "JUMPIFEQ" or op == "JUMPIFEQK" then
        return string.format("if v%d == v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPIFNOTEQ" or op == "JUMPIFNOTEQK" then
        return string.format("if v%d ~= v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPIFLE" then
        return string.format("if v%d <= v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPIFLT" then
        return string.format("if v%d < v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPIFNOTLE" then
        return string.format("if v%d > v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPIFNOTLT" then
        return string.format("if v%d >= v%d then -- jump", A, aux or 0)
        
    elseif op == "JUMPXEQKNIL" then
        return string.format("if v%d == nil then -- jump", A)
        
    elseif op == "JUMPXEQKB" then
        local boolVal = bit32.band(aux or 0, 1) == 1
        return string.format("if v%d == %s then -- jump", A, tostring(boolVal))
        
    elseif op == "JUMPXEQKN" or op == "JUMPXEQKS" then
        local constIdx = bit32.band(aux or 0, 0xFFFFFF)
        return string.format("if v%d == %s then -- jump", A, self:GetConstant(proto, constIdx))
        
    elseif op == "FORNPREP" then
        return string.format("for v%d = v%d, v%d, v%d do", A + 3, A, A + 1, A + 2)
        
    elseif op == "FORNLOOP" then
        return "end -- for numeric"
        
    elseif op == "FORGPREP" or op == "FORGPREP_NEXT" or op == "FORGPREP_INEXT" then
        return string.format("for v%d, v%d in v%d, v%d, v%d do", A + 3, A + 4, A, A + 1, A + 2)
        
    elseif op == "FORGLOOP" or op == "FORGLOOP_NEXT" or op == "FORGLOOP_INEXT" then
        return "end -- for generic"
        
    elseif op == "NEWCLOSURE" then
        local protoIdx = D
        return string.format("local v%d = function() end -- proto[%d]", A, protoIdx)
        
    elseif op == "DUPCLOSURE" then
        return string.format("local v%d = function() end -- dupclosure[%d]", A, D)
        
    elseif op == "GETVARARGS" then
        if B == 0 then
            return string.format("v%d, ... = ...", A)
        elseif B == 1 then
            return "-- getvarargs (0)"
        else
            local vars = {}
            for r = A, A + B - 2 do
                table.insert(vars, "v" .. r)
            end
            return string.format("%s = ...", table.concat(vars, ", "))
        end
        
    elseif op == "PREPVARARGS" then
        return "-- prepvarargs"
        
    elseif op == "SETLIST" then
        return string.format("-- setlist v%d count=%d", A, B)
        
    elseif op == "CLOSEUPVALS" then
        return string.format("-- closeupvals v%d+", A)
        
    elseif op == "CAPTURE" then
        local types = {[0] = "VAL", [1] = "REF", [2] = "UPVAL"}
        return string.format("-- capture %s v%d", types[A] or tostring(A), B)
        
    elseif op == "FASTCALL" or op == "FASTCALL1" or op == "FASTCALL2" or op == "FASTCALL2K" then
        return string.format("-- fastcall builtin=%d", A)
        
    else
        return string.format("-- %s A=%d B=%d C=%d D=%d", op, A, B, C, D)
    end
end

function Decompiler:DecompileProto(proto, name, protoIndex)
    -- Header
    local params = {}
    for i = 1, proto.numParams do
        table.insert(params, "arg" .. i)
    end
    if proto.isVararg then
        table.insert(params, "...")
    end
    
    local debugName = self:GetString(proto.debugName)
    if debugName and debugName ~= "" and debugName ~= "str_" .. proto.debugName then
        name = debugName
    end
    
    self:AddLine(string.format("local function %s(%s)", name or ("proto_" .. protoIndex), table.concat(params, ", ")))
    self.indent = self.indent + 1
    
    -- Meta info
    if proto.numUpvalues > 0 then
        self:AddLine(string.format("-- upvalues: %d", proto.numUpvalues))
    end
    
    -- Instructions
    for i, instr in ipairs(proto.instructions) do
        local line = self:DecompileInstruction(proto, instr, i)
        if line then
            self:AddLine(line)
        end
    end
    
    self.indent = self.indent - 1
    self:AddLine("end")
end

function Decompiler:DecompileBytecode(bytecode)
    if type(bytecode) ~= "string" or #bytecode == 0 then
        return nil, "Bytecode boÅŸ veya geÃ§ersiz!"
    end
    
    local reader = BytecodeReader.new(bytecode)
    
    -- Version check
    local version = reader:ReadByte()
    self.version = version
    
    if version == 0 then
        -- Hata mesajÄ± var mÄ± kontrol et
        local errorLen = reader:ReadVarInt()
        if errorLen > 0 then
            local errorMsg = string.sub(bytecode, reader.position, reader.position + errorLen - 1)
            return nil, "Bytecode hatasÄ±: " .. errorMsg
        end
        return nil, "Bytecode ÅŸifreli veya compile hatasÄ± var!"
    end
    
    if version < 3 then
        return nil, "Ã‡ok eski bytecode versiyonu: " .. version
    end
    
    if version > 6 then
        return nil, "Ã‡ok yeni bytecode versiyonu: " .. version .. " (desteklenen: 3-6)"
    end
    
    self.output = {}
    self.indent = 0
    
    self:AddLine("--[[")
    self:AddLine("    Custom Luau Decompiler v2")
    self:AddLine(string.format("    Bytecode Version: %d", version))
    self:AddLine("]]")
    self:AddLine("")
    
    -- Types version (version 4+)
    if version >= 4 then
        local typesVersion = reader:ReadByte()
    end
    
    -- String table
    local stringCount = reader:ReadVarInt()
    self.strings = {}
    
    for i = 1, stringCount do
        self.strings[i] = reader:ReadString()
    end
    
    self:AddLine(string.format("-- Strings: %d", stringCount))
    
    -- Proto table
    local protoCount = reader:ReadVarInt()
    self.protos = {}
    
    self:AddLine(string.format("-- Functions: %d", protoCount))
    self:AddLine("")
    
    for i = 1, protoCount do
        local success, result = pcall(ParseProto, reader, version, self.strings)
        if success then
            self.protos[i] = result
        else
            self:AddLine(string.format("-- Proto %d parse hatasÄ±: %s", i - 1, tostring(result)))
            self.protos[i] = nil
        end
    end
    
    -- Main proto ID
    local mainId = reader:ReadVarInt()
    
    self:AddLine(string.format("-- Main: proto[%d]", mainId))
    self:AddLine("")
    
    -- Decompile all protos
    for i, proto in ipairs(self.protos) do
        if proto then
            local success, err = pcall(function()
                local name = (i - 1 == mainId) and "main" or ("func_" .. (i - 1))
                self:DecompileProto(proto, name, i - 1)
                self:AddLine("")
            end)
            
            if not success then
                self:AddLine(string.format("-- Proto %d decompile hatasÄ±: %s", i - 1, tostring(err)))
                self:AddLine("")
            end
        end
    end
    
    self:AddLine("return main")
    
    return table.concat(self.output, "\n")
end

function Decompiler:DecompileScript(script)
    if not script then
        return nil, "Script nil!"
    end
    
    local className = script.ClassName
    if className ~= "LocalScript" and className ~= "ModuleScript" and className ~= "Script" then
        return nil, "GeÃ§ersiz script tÃ¼rÃ¼: " .. className
    end
    
    -- Bytecode al
    if not getscriptbytecode then
        return nil, "getscriptbytecode fonksiyonu bulunamadÄ±! Executor desteklemiyor."
    end
    
    local success, bytecode = pcall(getscriptbytecode, script)
    if not success then
        return nil, "Bytecode alÄ±namadÄ±: " .. tostring(bytecode)
    end
    
    if not bytecode or #bytecode == 0 then
        return nil, "Bytecode boÅŸ!"
    end
    
    -- Header
    local header = string.format([[
--[[
    Script: %s
    Path: %s
    Type: %s
    Size: %d bytes
]]

]], script.Name, script:GetFullName(), className, #bytecode)
    
    local code, err = self:DecompileBytecode(bytecode)
    if code then
        return header .. code
    else
        return nil, err
    end
end

--// ==================== GLOBAL FONKSÄ°YONLAR ====================
local DecompilerInstance = Decompiler.new()

_G.Decompile = function(scriptOrBytecode)
    if type(scriptOrBytecode) == "string" then
        return DecompilerInstance:DecompileBytecode(scriptOrBytecode)
    else
        return DecompilerInstance:DecompileScript(scriptOrBytecode)
    end
end

_G.DecompileAndCopy = function(script)
    local code, err = DecompilerInstance:DecompileScript(script)
    if code then
        if setclipboard then
            setclipboard(code)
            print("âœ… KopyalandÄ±!")
        else
            print("âš ï¸ setclipboard yok!")
        end
        return code
    else
        warn("âŒ", err)
        return nil, err
    end
end

_G.DecompileAndSave = function(script, fileName)
    local code, err = DecompilerInstance:DecompileScript(script)
    if code then
        fileName = fileName or (script.Name .. ".lua")
        if writefile then
            writefile(fileName, code)
            print("âœ… Kaydedildi:", fileName)
        else
            print("âš ï¸ writefile yok!")
        end
        return code
    else
        warn("âŒ", err)
        return nil, err
    end
end

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("  âœ… Custom Luau Decompiler v2 YÃ¼klendi")
print("  ğŸ“Œ Bytecode Version 3-6 Destekli")
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("")
print("KullanÄ±m:")
print("  local code = _G.Decompile(script)")
print("  _G.DecompileAndCopy(script)")
print("  _G.DecompileAndSave(script, 'dosya.lua')")
print("")

return Decompiler
