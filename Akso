--[[
    Custom Luau Decompiler
    Tek dosyada tam decompiler
    
    Kullanım:
    local code = Decompiler:DecompileScript(script)
    print(code)
]]

--// ==================== BYTECODE READER ====================
local BytecodeReader = {}
BytecodeReader.__index = BytecodeReader

function BytecodeReader.new(bytecode)
    local self = setmetatable({}, BytecodeReader)
    self.bytecode = bytecode
    self.position = 1
    self.length = #bytecode
    return self
end

function BytecodeReader:ReadByte()
    if self.position > self.length then return 0 end
    local byte = string.byte(self.bytecode, self.position)
    self.position = self.position + 1
    return byte
end

function BytecodeReader:ReadUInt32()
    local b1, b2, b3, b4 = self:ReadByte(), self:ReadByte(), self:ReadByte(), self:ReadByte()
    return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000)
end

function BytecodeReader:ReadInt32()
    local value = self:ReadUInt32()
    if value >= 0x80000000 then
        value = value - 0x100000000
    end
    return value
end

function BytecodeReader:ReadDouble()
    local bytes = {}
    for i = 1, 8 do bytes[i] = self:ReadByte() end
    
    local sign = (bytes[8] >= 128) and -1 or 1
    local exponent = ((bytes[8] % 128) * 16) + math.floor(bytes[7] / 16)
    local mantissa = (bytes[7] % 16)
    
    for i = 6, 1, -1 do
        mantissa = mantissa * 256 + bytes[i]
    end
    
    if exponent == 0 then
        return sign * (2 ^ -1022) * (mantissa / 0x10000000000000)
    elseif exponent == 2047 then
        return (mantissa == 0) and (sign * math.huge) or (0/0)
    end
    
    return sign * (2 ^ (exponent - 1023)) * (1 + mantissa / 0x10000000000000)
end

function BytecodeReader:ReadVarInt()
    local result, shift = 0, 0
    repeat
        local byte = self:ReadByte()
        result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
        shift = shift + 7
    until bit32.band(byte, 0x80) == 0
    return result
end

function BytecodeReader:ReadString()
    local length = self:ReadVarInt()
    if length == 0 then return "" end
    local str = string.sub(self.bytecode, self.position, self.position + length - 1)
    self.position = self.position + length
    return str
end

function BytecodeReader:ReadBytes(count)
    local bytes = {}
    for i = 1, count do bytes[i] = self:ReadByte() end
    return bytes
end

--// ==================== OPCODE TANIMLARI ====================
local OpcodeNames = {
    [0] = "NOP", [1] = "BREAK", [2] = "LOADNIL", [3] = "LOADB", [4] = "LOADN",
    [5] = "LOADK", [6] = "MOVE", [7] = "GETGLOBAL", [8] = "SETGLOBAL",
    [9] = "GETUPVAL", [10] = "SETUPVAL", [11] = "CLOSEUPVALS", [12] = "GETIMPORT",
    [13] = "GETTABLE", [14] = "SETTABLE", [15] = "GETTABLEKS", [16] = "SETTABLEKS",
    [17] = "GETTABLEN", [18] = "SETTABLEN", [19] = "NEWCLOSURE", [20] = "NAMECALL",
    [21] = "CALL", [22] = "RETURN", [23] = "JUMP", [24] = "JUMPBACK",
    [25] = "JUMPIF", [26] = "JUMPIFNOT", [27] = "JUMPIFEQ", [28] = "JUMPIFLE",
    [29] = "JUMPIFLT", [30] = "JUMPIFNOTEQ", [31] = "JUMPIFNOTLE", [32] = "JUMPIFNOTLT",
    [33] = "ADD", [34] = "SUB", [35] = "MUL", [36] = "DIV", [37] = "MOD",
    [38] = "POW", [39] = "ADDK", [40] = "SUBK", [41] = "MULK", [42] = "DIVK",
    [43] = "MODK", [44] = "POWK", [45] = "AND", [46] = "OR", [47] = "ANDK",
    [48] = "ORK", [49] = "CONCAT", [50] = "NOT", [51] = "MINUS", [52] = "LENGTH",
    [53] = "NEWTABLE", [54] = "DUPTABLE", [55] = "SETLIST", [56] = "FORNPREP",
    [57] = "FORNLOOP", [58] = "FORGLOOP", [59] = "FORGPREP_INEXT", [60] = "FORGLOOP_INEXT",
    [61] = "FORGPREP_NEXT", [62] = "FORGLOOP_NEXT", [63] = "GETVARARGS", [64] = "DUPCLOSURE",
    [65] = "PREPVARARGS", [66] = "LOADKX", [67] = "JUMPX", [68] = "FASTCALL",
    [69] = "COVERAGE", [70] = "CAPTURE", [71] = "JUMPIFEQK", [72] = "JUMPIFNOTEQK",
    [73] = "FASTCALL1", [74] = "FASTCALL2", [75] = "FASTCALL2K", [76] = "FORGPREP",
    [77] = "JUMPXEQKNIL", [78] = "JUMPXEQKB", [79] = "JUMPXEQKN", [80] = "JUMPXEQKS",
    [81] = "IDIV", [82] = "IDIVK"
}

--// ==================== INSTRUCTION DECODER ====================
local function DecodeInstruction(raw)
    local opcode = bit32.band(raw, 0xFF)
    local A = bit32.band(bit32.rshift(raw, 8), 0xFF)
    local B = bit32.band(bit32.rshift(raw, 16), 0xFF)
    local C = bit32.band(bit32.rshift(raw, 24), 0xFF)
    local D = bit32.band(bit32.rshift(raw, 16), 0xFFFF)
    
    if D >= 0x8000 then D = D - 0x10000 end
    
    return {
        raw = raw,
        opcode = opcode,
        opname = OpcodeNames[opcode] or ("UNKNOWN_" .. opcode),
        A = A, B = B, C = C, D = D,
        Bx = B + C * 256
    }
end

--// ==================== PROTO PARSER ====================
local function ParseProto(reader)
    local proto = {}
    
    proto.maxStackSize = reader:ReadByte()
    proto.numParams = reader:ReadByte()
    proto.numUpvalues = reader:ReadByte()
    proto.isVararg = reader:ReadByte() ~= 0
    proto.flags = reader:ReadByte()
    
    local typeinfoSize = reader:ReadVarInt()
    if typeinfoSize > 0 then
        reader:ReadBytes(typeinfoSize)
    end
    
    -- Instructions
    local instrCount = reader:ReadVarInt()
    proto.instructions = {}
    for i = 1, instrCount do
        proto.instructions[i] = DecodeInstruction(reader:ReadUInt32())
    end
    
    -- Constants
    local constCount = reader:ReadVarInt()
    proto.constants = {}
    
    for i = 1, constCount do
        local constType = reader:ReadByte()
        
        if constType == 0 then
            proto.constants[i] = {type = "nil", value = nil}
        elseif constType == 1 then
            proto.constants[i] = {type = "boolean", value = reader:ReadByte() ~= 0}
        elseif constType == 2 then
            proto.constants[i] = {type = "number", value = reader:ReadDouble()}
        elseif constType == 3 then
            proto.constants[i] = {type = "string", value = reader:ReadString()}
        elseif constType == 4 then
            proto.constants[i] = {type = "import", value = reader:ReadUInt32()}
        elseif constType == 5 then
            local tableSize = reader:ReadVarInt()
            local keys = {}
            for j = 1, tableSize do keys[j] = reader:ReadVarInt() end
            proto.constants[i] = {type = "table", value = keys}
        elseif constType == 6 then
            proto.constants[i] = {type = "closure", value = reader:ReadVarInt()}
        else
            proto.constants[i] = {type = "unknown", value = constType}
        end
    end
    
    -- Child protos
    local protoCount = reader:ReadVarInt()
    proto.childProtos = {}
    for i = 1, protoCount do
        proto.childProtos[i] = reader:ReadVarInt()
    end
    
    proto.lineDefined = reader:ReadVarInt()
    proto.debugName = reader:ReadVarInt()
    
    -- Line info
    local hasLineInfo = reader:ReadByte() ~= 0
    if hasLineInfo then
        local lineGapLog2 = reader:ReadByte()
        local intervals = bit32.rshift(#proto.instructions - 1, lineGapLog2) + 1
        
        for i = 1, #proto.instructions do reader:ReadByte() end
        for i = 1, intervals do reader:ReadInt32() end
    end
    
    -- Debug info
    local hasDebugInfo = reader:ReadByte() ~= 0
    if hasDebugInfo then
        local localCount = reader:ReadVarInt()
        proto.locals = {}
        for i = 1, localCount do
            proto.locals[i] = {
                name = reader:ReadVarInt(),
                startPc = reader:ReadVarInt(),
                endPc = reader:ReadVarInt(),
                reg = reader:ReadByte()
            }
        end
        
        local upvalueCount = reader:ReadVarInt()
        proto.upvalueNames = {}
        for i = 1, upvalueCount do
            proto.upvalueNames[i] = reader:ReadVarInt()
        end
    end
    
    return proto
end

--// ==================== ANA DECOMPILER ====================
local Decompiler = {}
Decompiler.__index = Decompiler

function Decompiler.new()
    local self = setmetatable({}, Decompiler)
    self.strings = {}
    self.protos = {}
    self.output = {}
    self.indent = 0
    return self
end

function Decompiler:AddLine(text)
    table.insert(self.output, string.rep("    ", self.indent) .. text)
end

function Decompiler:GetConstant(proto, index)
    local const = proto.constants[index + 1]
    if not const then return "nil" end
    
    if const.type == "nil" then
        return "nil"
    elseif const.type == "boolean" then
        return const.value and "true" or "false"
    elseif const.type == "number" then
        return tostring(const.value)
    elseif const.type == "string" then
        local escaped = const.value:gsub('\\', '\\\\'):gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\t', '\\t')
        return '"' .. escaped .. '"'
    else
        return "nil"
    end
end

function Decompiler:GetString(index)
    return self.strings[index] or ("str_" .. index)
end

function Decompiler:DecompileInstruction(proto, instr, pc)
    local op = instr.opname
    local A, B, C, D = instr.A, instr.B, instr.C, instr.D
    
    -- Temel instruction'lar
    if op == "NOP" or op == "BREAK" then
        return nil
        
    elseif op == "LOADNIL" then
        return string.format("local v%d = nil", A)
        
    elseif op == "LOADB" then
        return string.format("local v%d = %s", A, B == 1 and "true" or "false")
        
    elseif op == "LOADN" then
        return string.format("local v%d = %d", A, D)
        
    elseif op == "LOADK" then
        return string.format("local v%d = %s", A, self:GetConstant(proto, D))
        
    elseif op == "MOVE" then
        return string.format("v%d = v%d", A, B)
        
    elseif op == "GETGLOBAL" then
        local name = self:GetConstant(proto, instr.Bx):gsub('"', '')
        return string.format("local v%d = %s", A, name)
        
    elseif op == "SETGLOBAL" then
        local name = self:GetConstant(proto, instr.Bx):gsub('"', '')
        return string.format("%s = v%d", name, A)
        
    elseif op == "GETUPVAL" then
        return string.format("local v%d = upval_%d", A, B)
        
    elseif op == "SETUPVAL" then
        return string.format("upval_%d = v%d", B, A)
        
    elseif op == "GETTABLE" then
        return string.format("v%d = v%d[v%d]", A, B, C)
        
    elseif op == "SETTABLE" then
        return string.format("v%d[v%d] = v%d", B, C, A)
        
    elseif op == "GETTABLEKS" then
        local key = self:GetConstant(proto, C)
        if key:sub(1, 1) == '"' then
            return string.format("v%d = v%d.%s", A, B, key:sub(2, -2))
        end
        return string.format("v%d = v%d[%s]", A, B, key)
        
    elseif op == "SETTABLEKS" then
        local key = self:GetConstant(proto, C)
        if key:sub(1, 1) == '"' then
            return string.format("v%d.%s = v%d", B, key:sub(2, -2), A)
        end
        return string.format("v%d[%s] = v%d", B, key, A)
        
    elseif op == "GETTABLEN" then
        return string.format("v%d = v%d[%d]", A, B, C + 1)
        
    elseif op == "SETTABLEN" then
        return string.format("v%d[%d] = v%d", B, C + 1, A)
        
    elseif op == "NEWTABLE" then
        return string.format("local v%d = {}", A)
        
    elseif op == "ADD" then
        return string.format("v%d = v%d + v%d", A, B, C)
    elseif op == "SUB" then
        return string.format("v%d = v%d - v%d", A, B, C)
    elseif op == "MUL" then
        return string.format("v%d = v%d * v%d", A, B, C)
    elseif op == "DIV" then
        return string.format("v%d = v%d / v%d", A, B, C)
    elseif op == "MOD" then
        return string.format("v%d = v%d %% v%d", A, B, C)
    elseif op == "POW" then
        return string.format("v%d = v%d ^ v%d", A, B, C)
        
    elseif op == "ADDK" then
        return string.format("v%d = v%d + %s", A, B, self:GetConstant(proto, C))
    elseif op == "SUBK" then
        return string.format("v%d = v%d - %s", A, B, self:GetConstant(proto, C))
    elseif op == "MULK" then
        return string.format("v%d = v%d * %s", A, B, self:GetConstant(proto, C))
    elseif op == "DIVK" then
        return string.format("v%d = v%d / %s", A, B, self:GetConstant(proto, C))
        
    elseif op == "CONCAT" then
        local parts = {}
        for r = B, C do table.insert(parts, "v" .. r) end
        return string.format("v%d = %s", A, table.concat(parts, " .. "))
        
    elseif op == "NOT" then
        return string.format("v%d = not v%d", A, B)
        
    elseif op == "MINUS" then
        return string.format("v%d = -v%d", A, B)
        
    elseif op == "LENGTH" then
        return string.format("v%d = #v%d", A, B)
        
    elseif op == "CALL" then
        local args = {}
        if B > 1 then
            for r = A + 1, A + B - 1 do
                table.insert(args, "v" .. r)
            end
        elseif B == 0 then
            table.insert(args, "...")
        end
        
        if C == 1 then
            return string.format("v%d(%s)", A, table.concat(args, ", "))
        elseif C == 0 then
            return string.format("... = v%d(%s)", A, table.concat(args, ", "))
        else
            local rets = {}
            for r = A, A + C - 2 do
                table.insert(rets, "v" .. r)
            end
            return string.format("%s = v%d(%s)", table.concat(rets, ", "), A, table.concat(args, ", "))
        end
        
    elseif op == "RETURN" then
        if B == 1 then
            return "return"
        elseif B == 0 then
            return "return ..."
        else
            local rets = {}
            for r = A, A + B - 2 do
                table.insert(rets, "v" .. r)
            end
            return "return " .. table.concat(rets, ", ")
        end
        
    elseif op == "JUMP" then
        return string.format("-- jump -> %d", pc + D + 1)
        
    elseif op == "JUMPBACK" then
        return string.format("-- jumpback -> %d", pc + D + 1)
        
    elseif op == "JUMPIF" then
        return string.format("if v%d then", A)
        
    elseif op == "JUMPIFNOT" then
        return string.format("if not v%d then", A)
        
    elseif op == "JUMPIFEQ" then
        return string.format("if v%d == aux then", A)
        
    elseif op == "JUMPIFLE" then
        return string.format("if v%d <= aux then", A)
        
    elseif op == "JUMPIFLT" then
        return string.format("if v%d < aux then", A)
        
    elseif op == "JUMPIFNOTEQ" then
        return string.format("if v%d ~= aux then", A)
        
    elseif op == "FORNPREP" then
        return string.format("for v%d = v%d, v%d, v%d do", A + 3, A, A + 1, A + 2)
        
    elseif op == "FORNLOOP" then
        return "end"
        
    elseif op == "FORGPREP" or op == "FORGPREP_NEXT" or op == "FORGPREP_INEXT" then
        return string.format("for v%d, v%d in v%d, v%d, v%d do", A + 3, A + 4, A, A + 1, A + 2)
        
    elseif op == "FORGLOOP" or op == "FORGLOOP_NEXT" or op == "FORGLOOP_INEXT" then
        return "end"
        
    elseif op == "NEWCLOSURE" then
        return string.format("local v%d = function(...) --[[ proto_%d ]] end", A, D)
        
    elseif op == "DUPCLOSURE" then
        return string.format("local v%d = function(...) --[[ dupclosure_%d ]] end", A, D)
        
    elseif op == "NAMECALL" then
        local method = self:GetConstant(proto, C)
        if method:sub(1, 1) == '"' then
            method = method:sub(2, -2)
        end
        return string.format("-- namecall: v%d:%s()", B, method)
        
    elseif op == "GETIMPORT" then
        local k = proto.constants[D + 1]
        if k and k.type == "import" then
            return string.format("local v%d = import(%d)", A, k.value)
        end
        return string.format("local v%d = import_%d", A, D)
        
    elseif op == "GETVARARGS" then
        if B == 0 then
            return string.format("v%d = ...", A)
        else
            local vars = {}
            for r = A, A + B - 2 do
                table.insert(vars, "v" .. r)
            end
            return string.format("%s = ...", table.concat(vars, ", "))
        end
        
    elseif op == "PREPVARARGS" then
        return "-- prepvarargs"
        
    elseif op == "SETLIST" then
        return string.format("-- setlist v%d[%d]", A, B)
        
    elseif op == "CAPTURE" then
        local types = {[0] = "VAL", [1] = "REF", [2] = "UPVAL"}
        return string.format("-- capture %s v%d", types[A] or "?", B)
        
    elseif op == "CLOSEUPVALS" then
        return string.format("-- closeupvals v%d", A)
        
    elseif op == "FASTCALL" or op == "FASTCALL1" or op == "FASTCALL2" then
        return string.format("-- fastcall %d", A)
        
    elseif op == "COVERAGE" then
        return nil
        
    else
        return string.format("-- %s A=%d B=%d C=%d D=%d", op, A, B, C, D)
    end
end

function Decompiler:DecompileProto(proto, name)
    -- Fonksiyon header
    local params = {}
    for i = 1, proto.numParams do
        table.insert(params, "arg" .. i)
    end
    if proto.isVararg then
        table.insert(params, "...")
    end
    
    self:AddLine(string.format("function %s(%s)", name or "main", table.concat(params, ", ")))
    self.indent = self.indent + 1
    
    -- Comment: upvalues
    if proto.numUpvalues > 0 then
        self:AddLine(string.format("-- upvalues: %d", proto.numUpvalues))
    end
    
    -- Instructions
    for i, instr in ipairs(proto.instructions) do
        local line = self:DecompileInstruction(proto, instr, i)
        if line then
            self:AddLine(line)
        end
    end
    
    self.indent = self.indent - 1
    self:AddLine("end")
end

function Decompiler:DecompileBytecode(bytecode)
    if type(bytecode) ~= "string" or #bytecode == 0 then
        return nil, "Geçersiz bytecode!"
    end
    
    local reader = BytecodeReader.new(bytecode)
    
    -- Version
    local version = reader:ReadByte()
    if version == 0 then
        return nil, "Bytecode şifreli veya hatalı!"
    end
    
    if version < 3 or version > 6 then
        return nil, "Desteklenmeyen versiyon: " .. version
    end
    
    self.output = {}
    self.indent = 0
    
    self:AddLine("--[[")
    self:AddLine("    Custom Luau Decompiler")
    self:AddLine(string.format("    Bytecode Version: %d", version))
    self:AddLine("]]")
    self:AddLine("")
    
    -- Strings
    local stringCount = reader:ReadVarInt()
    self.strings = {}
    for i = 1, stringCount do
        self.strings[i] = reader:ReadString()
    end
    
    -- Protos
    local protoCount = reader:ReadVarInt()
    self.protos = {}
    for i = 1, protoCount do
        self.protos[i] = ParseProto(reader)
    end
    
    -- Main proto
    local mainId = reader:ReadVarInt()
    local mainProto = self.protos[mainId + 1]
    
    if mainProto then
        -- Child proto'ları önce decompile et
        for i, proto in ipairs(self.protos) do
            if i ~= mainId + 1 then
                self:DecompileProto(proto, "proto_" .. (i - 1))
                self:AddLine("")
            end
        end
        
        -- Main proto
        self:DecompileProto(mainProto, "main")
        self:AddLine("")
        self:AddLine("return main()")
    end
    
    return table.concat(self.output, "\n")
end

--// ==================== SCRIPT DECOMPILE ====================
function Decompiler:DecompileScript(script)
    if not script then
        return nil, "Script nil!"
    end
    
    if not script:IsA("LocalScript") and not script:IsA("ModuleScript") then
        return nil, "Sadece LocalScript ve ModuleScript destekleniyor!"
    end
    
    -- Bytecode al
    if not getscriptbytecode then
        return nil, "getscriptbytecode bulunamadı! Executor desteklemiyor."
    end
    
    local success, bytecode = pcall(getscriptbytecode, script)
    if not success then
        return nil, "Bytecode alınamadı: " .. tostring(bytecode)
    end
    
    if not bytecode or #bytecode == 0 then
        return nil, "Bytecode boş!"
    end
    
    -- Header
    local header = string.format([[
--[[
    Script: %s
    Path: %s
    Type: %s
]]

]], script.Name, script:GetFullName(), script.ClassName)
    
    local code, err = self:DecompileBytecode(bytecode)
    if code then
        return header .. code
    else
        return nil, err
    end
end

--// ==================== KOLAY KULLANIM ====================
local DecompilerInstance = Decompiler.new()

-- Global fonksiyonlar
_G.Decompile = function(script)
    return DecompilerInstance:DecompileScript(script)
end

_G.DecompileBytecode = function(bytecode)
    return DecompilerInstance:DecompileBytecode(bytecode)
end

-- Kopyalama ve kaydetme
_G.DecompileAndCopy = function(script)
    local code, err = DecompilerInstance:DecompileScript(script)
    if code then
        if setclipboard then
            setclipboard(code)
            print("✅ Decompile edildi ve kopyalandı!")
        end
        return code
    else
        warn("❌ Hata:", err)
        return nil
    end
end

_G.DecompileAndSave = function(script, fileName)
    local code, err = DecompilerInstance:DecompileScript(script)
    if code then
        fileName = fileName or (script.Name .. "_decompiled.lua")
        if writefile then
            writefile(fileName, code)
            print("✅ Kaydedildi:", fileName)
        end
        return code
    else
        warn("❌ Hata:", err)
        return nil
    end
end

print("✅ Custom Decompiler yüklendi!")
print("Kullanım:")
print("  _G.Decompile(script)")
print("  _G.DecompileAndCopy(script)")
print("  _G.DecompileAndSave(script)")

return Decompiler
