--// Bytecode Reader Class
local BytecodeReader = {}
BytecodeReader.__index = BytecodeReader

function BytecodeReader.new(bytecode)
    local self = setmetatable({}, BytecodeReader)
    self.bytecode = bytecode
    self.position = 1
    self.length = #bytecode
    return self
end

function BytecodeReader:ReadByte()
    if self.position > self.length then
        return 0
    end
    local byte = string.byte(self.bytecode, self.position)
    self.position = self.position + 1
    return byte
end

function BytecodeReader:ReadBytes(count)
    local bytes = {}
    for i = 1, count do
        bytes[i] = self:ReadByte()
    end
    return bytes
end

function BytecodeReader:ReadUInt32()
    local b1 = self:ReadByte()
    local b2 = self:ReadByte()
    local b3 = self:ReadByte()
    local b4 = self:ReadByte()
    return b1 + (b2 * 0x100) + (b3 * 0x10000) + (b4 * 0x1000000)
end

function BytecodeReader:ReadInt32()
    local value = self:ReadUInt32()
    if value >= 0x80000000 then
        value = value - 0x100000000
    end
    return value
end

function BytecodeReader:ReadFloat()
    local b1, b2, b3, b4 = self:ReadByte(), self:ReadByte(), self:ReadByte(), self:ReadByte()
    
    local sign = (b4 >= 128) and -1 or 1
    local exponent = ((b4 % 128) * 2) + math.floor(b3 / 128)
    local mantissa = ((b3 % 128) * 0x10000) + (b2 * 0x100) + b1
    
    if exponent == 0 then
        return sign * (2 ^ -126) * (mantissa / 0x800000)
    elseif exponent == 255 then
        return (mantissa == 0) and (sign * math.huge) or (0/0)
    end
    
    return sign * (2 ^ (exponent - 127)) * (1 + mantissa / 0x800000)
end

function BytecodeReader:ReadDouble()
    local bytes = self:ReadBytes(8)
    
    local sign = (bytes[8] >= 128) and -1 or 1
    local exponent = ((bytes[8] % 128) * 16) + math.floor(bytes[7] / 16)
    
    local mantissa = (bytes[7] % 16)
    for i = 6, 1, -1 do
        mantissa = mantissa * 256 + bytes[i]
    end
    
    if exponent == 0 then
        return sign * (2 ^ -1022) * (mantissa / 0x10000000000000)
    elseif exponent == 2047 then
        return (mantissa == 0) and (sign * math.huge) or (0/0)
    end
    
    return sign * (2 ^ (exponent - 1023)) * (1 + mantissa / 0x10000000000000)
end

-- Variable-length integer (Luau format)
function BytecodeReader:ReadVarInt()
    local result = 0
    local shift = 0
    
    repeat
        local byte = self:ReadByte()
        result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
        shift = shift + 7
    until bit32.band(byte, 0x80) == 0
    
    return result
end

function BytecodeReader:ReadString()
    local length = self:ReadVarInt()
    if length == 0 then
        return ""
    end
    
    local str = string.sub(self.bytecode, self.position, self.position + length - 1)
    self.position = self.position + length
    return str
end

function BytecodeReader:IsEnd()
    return self.position > self.length
end

--// Luau Opcode Definitions
local LuauOpcode = {
    NOP = 0,
    BREAK = 1,
    LOADNIL = 2,
    LOADB = 3,
    LOADN = 4,
    LOADK = 5,
    MOVE = 6,
    GETGLOBAL = 7,
    SETGLOBAL = 8,
    GETUPVAL = 9,
    SETUPVAL = 10,
    CLOSEUPVALS = 11,
    GETIMPORT = 12,
    GETTABLE = 13,
    SETTABLE = 14,
    GETTABLEKS = 15,
    SETTABLEKS = 16,
    GETTABLEN = 17,
    SETTABLEN = 18,
    NEWCLOSURE = 19,
    NAMECALL = 20,
    CALL = 21,
    RETURN = 22,
    JUMP = 23,
    JUMPBACK = 24,
    JUMPIF = 25,
    JUMPIFNOT = 26,
    JUMPIFEQ = 27,
    JUMPIFLE = 28,
    JUMPIFLT = 29,
    JUMPIFNOTEQ = 30,
    JUMPIFNOTLE = 31,
    JUMPIFNOTLT = 32,
    ADD = 33,
    SUB = 34,
    MUL = 35,
    DIV = 36,
    MOD = 37,
    POW = 38,
    ADDK = 39,
    SUBK = 40,
    MULK = 41,
    DIVK = 42,
    MODK = 43,
    POWK = 44,
    AND = 45,
    OR = 46,
    ANDK = 47,
    ORK = 48,
    CONCAT = 49,
    NOT = 50,
    MINUS = 51,
    LENGTH = 52,
    NEWTABLE = 53,
    DUPTABLE = 54,
    SETLIST = 55,
    FORNPREP = 56,
    FORNLOOP = 57,
    FORGLOOP = 58,
    FORGPREP_INEXT = 59,
    FORGLOOP_INEXT = 60,
    FORGPREP_NEXT = 61,
    FORGLOOP_NEXT = 62,
    GETVARARGS = 63,
    DUPCLOSURE = 64,
    PREPVARARGS = 65,
    LOADKX = 66,
    JUMPX = 67,
    FASTCALL = 68,
    COVERAGE = 69,
    CAPTURE = 70,
    JUMPIFEQK = 71,
    JUMPIFNOTEQK = 72,
    FASTCALL1 = 73,
    FASTCALL2 = 74,
    FASTCALL2K = 75,
    FORGPREP = 76,
    JUMPXEQKNIL = 77,
    JUMPXEQKB = 78,
    JUMPXEQKN = 79,
    JUMPXEQKS = 80,
    IDIV = 81,
    IDIVK = 82,
}

-- Opcode isimleri
local OpcodeNames = {}
for name, code in pairs(LuauOpcode) do
    OpcodeNames[code] = name
end

-- Opcode modları (A, B, C, D, E formatları)
local OpcodeModes = {
    [LuauOpcode.NOP] = "none",
    [LuauOpcode.BREAK] = "none",
    [LuauOpcode.LOADNIL] = "A",
    [LuauOpcode.LOADB] = "ABC",
    [LuauOpcode.LOADN] = "AD",
    [LuauOpcode.LOADK] = "AD",
    [LuauOpcode.MOVE] = "AB",
    [LuauOpcode.GETGLOBAL] = "AC",
    [LuauOpcode.SETGLOBAL] = "AC",
    [LuauOpcode.GETUPVAL] = "AB",
    [LuauOpcode.SETUPVAL] = "AB",
    [LuauOpcode.GETTABLE] = "ABC",
    [LuauOpcode.SETTABLE] = "ABC",
    [LuauOpcode.GETTABLEKS] = "ABC",
    [LuauOpcode.SETTABLEKS] = "ABC",
    [LuauOpcode.NEWTABLE] = "AB",
    [LuauOpcode.ADD] = "ABC",
    [LuauOpcode.SUB] = "ABC",
    [LuauOpcode.MUL] = "ABC",
    [LuauOpcode.DIV] = "ABC",
    [LuauOpcode.CALL] = "ABC",
    [LuauOpcode.RETURN] = "AB",
    [LuauOpcode.JUMP] = "D",
    [LuauOpcode.JUMPIF] = "AD",
    [LuauOpcode.JUMPIFNOT] = "AD",
    [LuauOpcode.FORNPREP] = "AD",
    [LuauOpcode.FORNLOOP] = "AD",
    [LuauOpcode.FORGLOOP] = "AD",
    [LuauOpcode.NEWCLOSURE] = "AD",
}

--// Instruction Decoder
local InstructionDecoder = {}
InstructionDecoder.__index = InstructionDecoder

function InstructionDecoder.new()
    local self = setmetatable({}, InstructionDecoder)
    return self
end

function InstructionDecoder:Decode(instruction)
    local opcode = bit32.band(instruction, 0xFF)
    local A = bit32.band(bit32.rshift(instruction, 8), 0xFF)
    local B = bit32.band(bit32.rshift(instruction, 16), 0xFF)
    local C = bit32.band(bit32.rshift(instruction, 24), 0xFF)
    
    -- D format (signed 16-bit)
    local D = bit32.band(bit32.rshift(instruction, 16), 0xFFFF)
    if D >= 0x8000 then
        D = D - 0x10000
    end
    
    -- E format (signed 24-bit)
    local E = bit32.band(bit32.rshift(instruction, 8), 0xFFFFFF)
    if E >= 0x800000 then
        E = E - 0x1000000
    end
    
    return {
        raw = instruction,
        opcode = opcode,
        opname = OpcodeNames[opcode] or "UNKNOWN_" .. opcode,
        A = A,
        B = B,
        C = C,
        D = D,
        E = E,
        Bx = B + C * 256,
        sBx = (B + C * 256) - 32767
    }
end

--// Proto Parser - Fonksiyon yapısını parse eder
local ProtoParser = {}
ProtoParser.__index = ProtoParser

function ProtoParser.new(reader)
    local self = setmetatable({}, ProtoParser)
    self.reader = reader
    return self
end

function ProtoParser:Parse()
    local proto = {}
    
    -- Max stack size
    proto.maxStackSize = self.reader:ReadByte()
    
    -- Parametre sayısı
    proto.numParams = self.reader:ReadByte()
    
    -- Upvalue sayısı
    proto.numUpvalues = self.reader:ReadByte()
    
    -- Is vararg
    proto.isVararg = self.reader:ReadByte() ~= 0
    
    -- Flags (Luau 3+)
    proto.flags = self.reader:ReadByte()
    
    -- Typeinfo size
    local typeinfoSize = self.reader:ReadVarInt()
    if typeinfoSize > 0 then
        proto.typeinfo = self.reader:ReadBytes(typeinfoSize)
    end
    
    -- Instructions
    local instrCount = self.reader:ReadVarInt()
    proto.instructions = {}
    
    local decoder = InstructionDecoder.new()
    for i = 1, instrCount do
        local raw = self.reader:ReadUInt32()
        proto.instructions[i] = decoder:Decode(raw)
    end
    
    -- Constants
    local constCount = self.reader:ReadVarInt()
    proto.constants = {}
    
    for i = 1, constCount do
        local constType = self.reader:ReadByte()
        
        if constType == 0 then -- Nil
            proto.constants[i] = {type = "nil", value = nil}
        elseif constType == 1 then -- Boolean
            proto.constants[i] = {type = "boolean", value = self.reader:ReadByte() ~= 0}
        elseif constType == 2 then -- Number
            proto.constants[i] = {type = "number", value = self.reader:ReadDouble()}
        elseif constType == 3 then -- String
            proto.constants[i] = {type = "string", value = self.reader:ReadString()}
        elseif constType == 4 then -- Import
            proto.constants[i] = {type = "import", value = self.reader:ReadUInt32()}
        elseif constType == 5 then -- Table
            local tableSize = self.reader:ReadVarInt()
            local keys = {}
            for j = 1, tableSize do
                keys[j] = self.reader:ReadVarInt()
            end
            proto.constants[i] = {type = "table", value = keys}
        elseif constType == 6 then -- Closure
            proto.constants[i] = {type = "closure", value = self.reader:ReadVarInt()}
        else
            proto.constants[i] = {type = "unknown", value = constType}
        end
    end
    
    -- Child protos
    local protoCount = self.reader:ReadVarInt()
    proto.childProtos = {}
    for i = 1, protoCount do
        proto.childProtos[i] = self.reader:ReadVarInt()
    end
    
    -- Line info
    proto.lineDefined = self.reader:ReadVarInt()
    
    -- Debug name
    local debugNameIdx = self.reader:ReadVarInt()
    proto.debugName = debugNameIdx
    
    -- Line info (optional)
    local hasLineInfo = self.reader:ReadByte() ~= 0
    if hasLineInfo then
        local lineGapLog2 = self.reader:ReadByte()
        
        local intervals = bit32.rshift(instrCount - 1, lineGapLog2) + 1
        
        for i = 1, instrCount do
            self.reader:ReadByte() -- lineinfo
        end
        
        for i = 1, intervals do
            self.reader:ReadInt32() -- abslineinfo
        end
    end
    
    -- Debug info (optional)
    local hasDebugInfo = self.reader:ReadByte() ~= 0
    if hasDebugInfo then
        local localCount = self.reader:ReadVarInt()
        proto.locals = {}
        
        for i = 1, localCount do
            proto.locals[i] = {
                name = self.reader:ReadVarInt(),
                startPc = self.reader:ReadVarInt(),
                endPc = self.reader:ReadVarInt(),
                reg = self.reader:ReadByte()
            }
        end
        
        local upvalueCount = self.reader:ReadVarInt()
        proto.upvalueNames = {}
        for i = 1, upvalueCount do
            proto.upvalueNames[i] = self.reader:ReadVarInt()
        end
    end
    
    return proto
end

--// Ana Decompiler Class
local LuauDecompiler = {}
LuauDecompiler.__index = LuauDecompiler

function LuauDecompiler.new()
    local self = setmetatable({}, LuauDecompiler)
    self.strings = {}
    self.protos = {}
    self.mainProto = nil
    self.output = {}
    self.indent = 0
    self.varCounter = 0
    return self
end

function LuauDecompiler:AddLine(text)
    local indentStr = string.rep("    ", self.indent)
    table.insert(self.output, indentStr .. text)
end

function LuauDecompiler:NewVar()
    self.varCounter = self.varCounter + 1
    return "v" .. self.varCounter
end

function LuauDecompiler:GetConstant(proto, index)
    local const = proto.constants[index + 1]
    if not const then return "nil" end
    
    if const.type == "nil" then
        return "nil"
    elseif const.type == "boolean" then
        return const.value and "true" or "false"
    elseif const.type == "number" then
        return tostring(const.value)
    elseif const.type == "string" then
        return string.format('"%s"', const.value:gsub('"', '\\"'):gsub("\n", "\\n"))
    else
        return "nil --[[ " .. const.type .. " ]]"
    end
end

function LuauDecompiler:GetString(index)
    return self.strings[index] or ("string_" .. index)
end

function LuauDecompiler:DecompileProto(proto, name)
    name = name or "main"
    
    -- Fonksiyon header
    local params = {}
    for i = 1, proto.numParams do
        table.insert(params, "arg" .. i)
    end
    if proto.isVararg then
        table.insert(params, "...")
    end
    
    self:AddLine(string.format("local function %s(%s)", name, table.concat(params, ", ")))
    self.indent = self.indent + 1
    
    -- Upvalues comment
    if proto.numUpvalues > 0 then
        self:AddLine(string.format("-- Upvalues: %d", proto.numUpvalues))
    end
    
    -- Instructions decompile
    local registers = {}
    local i = 1
    
    while i <= #proto.instructions do
        local instr = proto.instructions[i]
        local op = instr.opname
        local A, B, C, D = instr.A, instr.B, instr.C, instr.D
        
        local line = self:DecompileInstruction(proto, instr, registers, i)
        if line and line ~= "" then
            self:AddLine(line)
        end
        
        i = i + 1
    end
    
    self.indent = self.indent - 1
    self:AddLine("end")
end

function LuauDecompiler:DecompileInstruction(proto, instr, registers, pc)
    local op = instr.opname
    local A, B, C, D = instr.A, instr.B, instr.C, instr.D
    
    local function reg(r)
        return registers[r] or ("v" .. r)
    end
    
    if op == "NOP" then
        return ""
        
    elseif op == "LOADNIL" then
        registers[A] = "nil"
        return string.format("local v%d = nil", A)
        
    elseif op == "LOADB" then
        local value = B == 1 and "true" or "false"
        registers[A] = value
        return string.format("local v%d = %s", A, value)
        
    elseif op == "LOADN" then
        registers[A] = tostring(D)
        return string.format("local v%d = %d", A, D)
        
    elseif op == "LOADK" then
        local const = self:GetConstant(proto, D)
        registers[A] = const
        return string.format("local v%d = %s", A, const)
        
    elseif op == "MOVE" then
        registers[A] = reg(B)
        return string.format("v%d = v%d", A, B)
        
    elseif op == "GETGLOBAL" then
        local name = self:GetConstant(proto, instr.Bx)
        registers[A] = name
        return string.format("local v%d = %s", A, name)
        
    elseif op == "SETGLOBAL" then
        local name = self:GetConstant(proto, instr.Bx)
        return string.format("%s = v%d", name, A)
        
    elseif op == "GETUPVAL" then
        return string.format("local v%d = upval_%d", A, B)
        
    elseif op == "SETUPVAL" then
        return string.format("upval_%d = v%d", B, A)
        
    elseif op == "GETTABLE" then
        return string.format("v%d = v%d[v%d]", A, B, C)
        
    elseif op == "SETTABLE" then
        return string.format("v%d[v%d] = v%d", B, C, A)
        
    elseif op == "GETTABLEKS" then
        local key = self:GetConstant(proto, C)
        -- String constant ise . kullan
        if key:sub(1,1) == '"' then
            key = key:sub(2, -2) -- quotes kaldır
            return string.format("v%d = v%d.%s", A, B, key)
        end
        return string.format("v%d = v%d[%s]", A, B, key)
        
    elseif op == "SETTABLEKS" then
        local key = self:GetConstant(proto, C)
        if key:sub(1,1) == '"' then
            key = key:sub(2, -2)
            return string.format("v%d.%s = v%d", B, key, A)
        end
        return string.format("v%d[%s] = v%d", B, key, A)
        
    elseif op == "NEWTABLE" then
        return string.format("local v%d = {}", A)
        
    elseif op == "ADD" then
        return string.format("v%d = v%d + v%d", A, B, C)
    elseif op == "SUB" then
        return string.format("v%d = v%d - v%d", A, B, C)
    elseif op == "MUL" then
        return string.format("v%d = v%d * v%d", A, B, C)
    elseif op == "DIV" then
        return string.format("v%d = v%d / v%d", A, B, C)
    elseif op == "MOD" then
        return string.format("v%d = v%d %% v%d", A, B, C)
    elseif op == "POW" then
        return string.format("v%d = v%d ^ v%d", A, B, C)
        
    elseif op == "ADDK" then
        local k = self:GetConstant(proto, C)
        return string.format("v%d = v%d + %s", A, B, k)
        
    elseif op == "CONCAT" then
        local parts = {}
        for r = B, C do
            table.insert(parts, "v" .. r)
        end
        return string.format("v%d = %s", A, table.concat(parts, " .. "))
        
    elseif op == "NOT" then
        return string.format("v%d = not v%d", A, B)
        
    elseif op == "MINUS" then
        return string.format("v%d = -v%d", A, B)
        
    elseif op == "LENGTH" then
        return string.format("v%d = #v%d", A, B)
        
    elseif op == "CALL" then
        local args = {}
        for r = A + 1, A + B - 1 do
            table.insert(args, "v" .. r)
        end
        
        if C == 0 then
            return string.format("v%d(%s)", A, table.concat(args, ", "))
        elseif C == 1 then
            return string.format("v%d(%s)", A, table.concat(args, ", "))
        else
            local rets = {}
            for r = A, A + C - 2 do
                table.insert(rets, "v" .. r)
            end
            return string.format("%s = v%d(%s)", table.concat(rets, ", "), A, table.concat(args, ", "))
        end
        
    elseif op == "RETURN" then
        if B == 0 then
            return "return"
        elseif B == 1 then
            return "return"
        else
            local rets = {}
            for r = A, A + B - 2 do
                table.insert(rets, "v" .. r)
            end
            return string.format("return %s", table.concat(rets, ", "))
        end
        
    elseif op == "JUMP" then
        return string.format("-- JUMP -> %d", pc + D + 1)
        
    elseif op == "JUMPIF" then
        return string.format("if v%d then -- jump %d", A, D)
        
    elseif op == "JUMPIFNOT" then
        return string.format("if not v%d then -- jump %d", A, D)
        
    elseif op == "JUMPIFEQ" then
        return string.format("if v%d == v%d then -- jump", A, D)
        
    elseif op == "JUMPIFLT" then
        return string.format("if v%d < v%d then -- jump", A, D)
        
    elseif op == "JUMPIFLE" then
        return string.format("if v%d <= v%d then -- jump", A, D)
        
    elseif op == "FORNPREP" then
        return string.format("for v%d = v%d, v%d, v%d do", A + 3, A, A + 1, A + 2)
        
    elseif op == "FORNLOOP" then
        return "end -- for loop"
        
    elseif op == "FORGPREP" or op == "FORGPREP_NEXT" or op == "FORGPREP_INEXT" then
        return string.format("for v%d, v%d in v%d, v%d, v%d do", A + 3, A + 4, A, A + 1, A + 2)
        
    elseif op == "FORGLOOP" or op == "FORGLOOP_NEXT" or op == "FORGLOOP_INEXT" then
        return "end -- for in loop"
        
    elseif op == "NEWCLOSURE" then
        return string.format("local v%d = function() end -- closure %d", A, D)
        
    elseif op == "NAMECALL" then
        local method = self:GetConstant(proto, C)
        if method:sub(1,1) == '"' then
            method = method:sub(2, -2)
        end
        return string.format("-- NAMECALL v%d:%s", B, method)
        
    elseif op == "GETIMPORT" then
        return string.format("local v%d = import_%d", A, D)
        
    elseif op == "CAPTURE" then
        local captureTypes = {[0] = "VAL", [1] = "REF", [2] = "UPVAL"}
        return string.format("-- CAPTURE %s v%d", captureTypes[A] or "?", B)
        
    else
        return string.format("-- %s A=%d B=%d C=%d D=%d", op, A, B, C, D)
    end
end

--// Ana decompile fonksiyonu
function LuauDecompiler:Decompile(bytecode)
    if type(bytecode) ~= "string" then
        return nil, "Bytecode string olmalı!"
    end
    
    local reader = BytecodeReader.new(bytecode)
    
    -- Version check
    local version = reader:ReadByte()
    if version == 0 then
        return nil, "Bytecode hatalı veya şifreli!"
    end
    
    if version < 3 or version > 5 then
        return nil, "Desteklenmeyen bytecode versiyonu: " .. version
    end
    
    self.output = {}
    self:AddLine("--[[ Decompiled by Custom Luau Decompiler ]]")
    self:AddLine(string.format("-- Bytecode Version: %d", version))
    self:AddLine("")
    
    -- String table
    local stringCount = reader:ReadVarInt()
    self.strings = {}
    
    for i = 1, stringCount do
        self.strings[i] = reader:ReadString()
    end
    
    self:AddLine(string.format("-- Strings: %d", stringCount))
    
    -- Proto table
    local protoCount = reader:ReadVarInt()
    self.protos = {}
    
    self:AddLine(string.format("-- Protos: %d", protoCount))
    self:AddLine("")
    
    local protoParser = ProtoParser.new(reader)
    
    for i = 1, protoCount do
        self.protos[i] = protoParser:Parse()
    end
    
    -- Main proto
    local mainProtoId = reader:ReadVarInt()
    self.mainProto = self.protos[mainProtoId + 1]
    
    -- Decompile main proto
    if self.mainProto then
        self:DecompileProto(self.mainProto, "main")
        self:AddLine("")
        self:AddLine("return main")
    end
    
    return table.concat(self.output, "\n")
end

--// Script'ten bytecode al ve decompile et
function LuauDecompiler:DecompileScript(script)
    if not script then
        return nil, "Script nil!"
    end
    
    -- Bytecode'u al
    local bytecode
    
    if getscriptbytecode then
        local success, result = pcall(getscriptbytecode, script)
        if success then
            bytecode = result
        else
            return nil, "Bytecode alınamadı: " .. tostring(result)
        end
    else
        return nil, "getscriptbytecode fonksiyonu bulunamadı!"
    end
    
    if not bytecode or bytecode == "" then
        return nil, "Bytecode boş!"
    end
    
    -- Header ekle
    local header = string.format(
        "--[[\n    Script: %s\n    Path: %s\n    Type: %s\n]]\n\n",
        script.Name,
        script:GetFullName(),
        script.ClassName
    )
    
    local code, err = self:Decompile(bytecode)
    
    if code then
        return header .. code
    else
        return nil, err
    end
end

return LuauDecompiler
