--[[
    Professional Roblox Luau Decompiler
    Executor API Destekli
    Eğlence Amaçlı Eğitim Projesi
]]

local Decompiler = {}
Decompiler.__index = Decompiler

-- Konfigürasyon
local Config = {
    IndentChar = "    ",
    MaxDepth = 50,
    ShowBytecodeComments = true,
    ShowUpvalueInfo = true,
    ShowConstantPool = true
}

-- Luau Opcode Tablosu (Luau bytecode format)
local Opcodes = {
    [0] = "NOP",
    [1] = "BREAK",
    [2] = "LOADNIL",
    [3] = "LOADB",
    [4] = "LOADN",
    [5] = "LOADK",
    [6] = "MOVE",
    [7] = "GETGLOBAL",
    [8] = "SETGLOBAL",
    [9] = "GETUPVAL",
    [10] = "SETUPVAL",
    [11] = "CLOSEUPVALS",
    [12] = "GETIMPORT",
    [13] = "GETTABLE",
    [14] = "SETTABLE",
    [15] = "GETTABLEKS",
    [16] = "SETTABLEKS",
    [17] = "GETTABLEN",
    [18] = "SETTABLEN",
    [19] = "NEWCLOSURE",
    [20] = "NAMECALL",
    [21] = "CALL",
    [22] = "RETURN",
    [23] = "JUMP",
    [24] = "JUMPBACK",
    [25] = "JUMPIF",
    [26] = "JUMPIFNOT",
    [27] = "JUMPIFEQ",
    [28] = "JUMPIFLE",
    [29] = "JUMPIFLT",
    [30] = "JUMPIFNOTEQ",
    [31] = "JUMPIFNOTLE",
    [32] = "JUMPIFNOTLT",
    [33] = "ADD",
    [34] = "SUB",
    [35] = "MUL",
    [36] = "DIV",
    [37] = "MOD",
    [38] = "POW",
    [39] = "ADDK",
    [40] = "SUBK",
    [41] = "MULK",
    [42] = "DIVK",
    [43] = "MODK",
    [44] = "POWK",
    [45] = "AND",
    [46] = "OR",
    [47] = "ANDK",
    [48] = "ORK",
    [49] = "CONCAT",
    [50] = "NOT",
    [51] = "MINUS",
    [52] = "LENGTH",
    [53] = "NEWTABLE",
    [54] = "DUPTABLE",
    [55] = "SETLIST",
    [56] = "FORNPREP",
    [57] = "FORNLOOP",
    [58] = "FORGLOOP",
    [59] = "FORGPREP_INEXT",
    [60] = "FORGLOOP_INEXT",
    [61] = "FORGPREP_NEXT",
    [62] = "FORGLOOP_NEXT",
    [63] = "GETVARARGS",
    [64] = "DUPCLOSURE",
    [65] = "PREPVARARGS",
    [66] = "LOADKX",
    [67] = "JUMPX",
    [68] = "FASTCALL",
    [69] = "COVERAGE",
    [70] = "CAPTURE",
    [71] = "FASTCALL1",
    [72] = "FASTCALL2",
    [73] = "FASTCALL2K",
    [74] = "FORGPREP",
    [75] = "JUMPXEQKNIL",
    [76] = "JUMPXEQKB",
    [77] = "JUMPXEQKN",
    [78] = "JUMPXEQKS"
}

function Decompiler.new()
    local self = setmetatable({}, Decompiler)
    self.output = {}
    self.indentLevel = 0
    self.varCounter = 0
    self.labelCounter = 0
    self.analyzedFunctions = {}
    return self
end

-- Indent yönetimi
function Decompiler:indent()
    self.indentLevel = self.indentLevel + 1
end

function Decompiler:dedent()
    self.indentLevel = math.max(0, self.indentLevel - 1)
end

function Decompiler:getIndent()
    return string.rep(Config.IndentChar, self.indentLevel)
end

function Decompiler:emit(code)
    table.insert(self.output, self:getIndent() .. code)
end

function Decompiler:emitRaw(code)
    table.insert(self.output, code)
end

-- Değişken ismi üret
function Decompiler:genVar(prefix)
    self.varCounter = self.varCounter + 1
    return (prefix or "var") .. "_" .. self.varCounter
end

-- Label üret
function Decompiler:genLabel()
    self.labelCounter = self.labelCounter + 1
    return "label_" .. self.labelCounter
end

--[[
    BYTECODE ANALİZ SİSTEMİ
]]

local BytecodeAnalyzer = {}

-- Bytecode'u parse et
function BytecodeAnalyzer.parseBytecode(bytecode)
    if not bytecode or #bytecode == 0 then
        return nil, "Boş bytecode"
    end
    
    local result = {
        version = 0,
        typeCount = 0,
        stringCount = 0,
        strings = {},
        protoCount = 0,
        protos = {},
        mainProto = 0
    }
    
    local pos = 1
    
    -- Helper: byte oku
    local function readByte()
        if pos > #bytecode then return 0 end
        local b = string.byte(bytecode, pos)
        pos = pos + 1
        return b
    end
    
    -- Helper: varint oku (Luau compressed integer)
    local function readVarInt()
        local result = 0
        local shift = 0
        repeat
            local byte = readByte()
            result = result + bit32.lshift(bit32.band(byte, 0x7F), shift)
            shift = shift + 7
        until bit32.band(byte, 0x80) == 0
        return result
    end
    
    -- Helper: string oku
    local function readString()
        local len = readVarInt()
        if len == 0 then return "" end
        local str = string.sub(bytecode, pos, pos + len - 1)
        pos = pos + len
        return str
    end
    
    -- Helper: 4 byte integer oku
    local function readInt32()
        local b1, b2, b3, b4 = string.byte(bytecode, pos, pos + 3)
        pos = pos + 4
        return b1 + b2 * 256 + b3 * 65536 + b4 * 16777216
    end
    
    -- Luau bytecode version (ilk byte)
    result.version = readByte()
    
    -- Type count
    result.typeCount = readVarInt()
    
    -- String table
    result.stringCount = readVarInt()
    for i = 1, result.stringCount do
        result.strings[i] = readString()
    end
    
    -- Proto count
    result.protoCount = readVarInt()
    
    -- Her proto için
    for i = 1, result.protoCount do
        local proto = {
            maxStackSize = readByte(),
            numParams = readByte(),
            numUpvalues = readByte(),
            isVararg = readByte(),
            flags = readByte(),
            typeInfo = {},
            instructions = {},
            constants = {},
            protos = {},
            lineInfo = {},
            debugName = ""
        }
        
        -- Type info (flags'e göre)
        if bit32.band(proto.flags, 0x01) ~= 0 then
            local typeSize = readVarInt()
            for j = 1, typeSize do
                proto.typeInfo[j] = readByte()
            end
        end
        
        -- Instructions
        local codeSize = readVarInt()
        for j = 1, codeSize do
            proto.instructions[j] = readInt32()
        end
        
        -- Constants
        local constSize = readVarInt()
        for j = 1, constSize do
            local constType = readByte()
            if constType == 0 then -- nil
                proto.constants[j] = {type = "nil", value = nil}
            elseif constType == 1 then -- boolean
                proto.constants[j] = {type = "boolean", value = readByte() ~= 0}
            elseif constType == 2 then -- number
                local bytes = {}
                for k = 1, 8 do bytes[k] = readByte() end
                -- Double precision float decode (basit versiyon)
                proto.constants[j] = {type = "number", value = 0, raw = bytes}
            elseif constType == 3 then -- string
                local idx = readVarInt()
                proto.constants[j] = {type = "string", value = result.strings[idx] or ""}
            elseif constType == 4 then -- import
                proto.constants[j] = {type = "import", value = readInt32()}
            elseif constType == 5 then -- table
                local keys = readVarInt()
                local tbl = {}
                for k = 1, keys do
                    tbl[k] = readVarInt()
                end
                proto.constants[j] = {type = "table", value = tbl}
            elseif constType == 6 then -- closure
                proto.constants[j] = {type = "closure", value = readVarInt()}
            end
        end
        
        -- Child protos
        local protoRefSize = readVarInt()
        for j = 1, protoRefSize do
            proto.protos[j] = readVarInt()
        end
        
        -- Line info (opsiyonel)
        local lineDefined = readVarInt()
        if lineDefined ~= 0 then
            proto.lineDefined = lineDefined
            local lineGapLog2 = readByte()
            
            local intervals = bit32.rshift(#proto.instructions - 1, lineGapLog2) + 1
            
            for j = 1, #proto.instructions do
                proto.lineInfo[j] = readByte()
            end
            
            for j = 1, intervals do
                readInt32() -- absline info
            end
        end
        
        -- Debug info (opsiyonel)
        local hasDebugInfo = readByte() ~= 0
        if hasDebugInfo then
            local nameIdx = readVarInt()
            proto.debugName = result.strings[nameIdx] or ""
            
            -- Local variables
            local localCount = readVarInt()
            proto.locals = {}
            for j = 1, localCount do
                local localNameIdx = readVarInt()
                local startPc = readVarInt()
                local endPc = readVarInt()
                local reg = readByte()
                proto.locals[j] = {
                    name = result.strings[localNameIdx] or ("local_" .. j),
                    startPc = startPc,
                    endPc = endPc,
                    reg = reg
                }
            end
            
            -- Upvalues
            local upvalCount = readVarInt()
            proto.upvalueNames = {}
            for j = 1, upvalCount do
                local upvalNameIdx = readVarInt()
                proto.upvalueNames[j] = result.strings[upvalNameIdx] or ("upval_" .. j)
            end
        end
        
        result.protos[i] = proto
    end
    
    -- Main proto index
    result.mainProto = readVarInt() + 1
    
    return result
end

-- Instruction decode
function BytecodeAnalyzer.decodeInstruction(inst)
    local opcode = bit32.band(inst, 0xFF)
    local A = bit32.band(bit32.rshift(inst, 8), 0xFF)
    local B = bit32.band(bit32.rshift(inst, 16), 0xFF)
    local C = bit32.band(bit32.rshift(inst, 24), 0xFF)
    local Bx = bit32.band(bit32.rshift(inst, 16), 0xFFFF)
    local sBx = Bx - 32767
    local D = bit32.band(bit32.rshift(inst, 16), 0xFFFF)
    local sD = D - 32767
    
    return {
        opcode = opcode,
        opname = Opcodes[opcode] or ("UNKNOWN_" .. opcode),
        A = A,
        B = B,
        C = C,
        Bx = Bx,
        sBx = sBx,
        D = D,
        sD = sD,
        raw = inst
    }
end

--[[
    FONKSİYON ANALİZ SİSTEMİ
    Executor API kullanarak
]]

local FunctionAnalyzer = {}

function FunctionAnalyzer.analyze(func)
    if type(func) ~= "function" then
        return nil, "Fonksiyon değil"
    end
    
    local analysis = {
        bytecode = nil,
        constants = {},
        upvalues = {},
        protos = {},
        info = nil,
        environment = nil
    }
    
    -- Bytecode al
    if getscriptbytecode then
        -- Script için
        pcall(function()
            analysis.bytecode = getscriptbytecode(func)
        end)
    end
    
    -- Function info
    if debug.getinfo then
        pcall(function()
            analysis.info = debug.getinfo(func)
        end)
    end
    
    -- Constants
    if debug.getconstants then
        pcall(function()
            analysis.constants = debug.getconstants(func)
        end)
    end
    
    -- Upvalues
    if debug.getupvalues then
        pcall(function()
            analysis.upvalues = debug.getupvalues(func)
        end)
    end
    
    -- Protos (nested functions)
    if debug.getprotos then
        pcall(function()
            analysis.protos = debug.getprotos(func)
        end)
    end
    
    -- Environment
    if getfenv then
        pcall(function()
            analysis.environment = getfenv(func)
        end)
    end
    
    return analysis
end

-- Detaylı constant analizi
function FunctionAnalyzer.analyzeConstants(func)
    local result = {}
    
    if not debug.getconstants then
        return result, "debug.getconstants mevcut değil"
    end
    
    local constants = debug.getconstants(func)
    
    for idx, value in pairs(constants) do
        local constInfo = {
            index = idx,
            value = value,
            type = type(value),
            details = {}
        }
        
        if type(value) == "string" then
            constInfo.details.length = #value
            constInfo.details.isIdentifier = value:match("^[%a_][%w_]*$") ~= nil
            constInfo.details.isPossibleMethod = value:match("^[A-Z]") ~= nil
        elseif type(value) == "number" then
            constInfo.details.isInteger = value == math.floor(value)
            constInfo.details.isNegative = value < 0
        elseif type(value) == "function" then
            constInfo.details.isBuiltin = pcall(function()
                return debug.getinfo(value).what == "C"
            end)
        end
        
        table.insert(result, constInfo)
    end
    
    return result
end

-- Upvalue analizi
function FunctionAnalyzer.analyzeUpvalues(func)
    local result = {}
    
    if not debug.getupvalues then
        return result, "debug.getupvalues mevcut değil"
    end
    
    local upvalues = debug.getupvalues(func)
    
    for idx, value in pairs(upvalues) do
        local upvalInfo = {
            index = idx,
            value = value,
            type = type(value),
            name = nil
        }
        
        -- İsim almaya çalış
        if debug.getupvalue then
            pcall(function()
                local name = debug.getupvalue(func, idx)
                upvalInfo.name = name
            end)
        end
        
        table.insert(result, upvalInfo)
    end
    
    return result
end

--[[
    SCRIPT ANALİZ SİSTEMİ
    Script objelerini analiz et
]]

local ScriptAnalyzer = {}

function ScriptAnalyzer.getScriptBytecode(script)
    if not getscriptbytecode then
        return nil, "getscriptbytecode mevcut değil"
    end
    
    local success, bytecode = pcall(getscriptbytecode, script)
    if not success then
        return nil, bytecode
    end
    
    return bytecode
end

function ScriptAnalyzer.getScriptClosure(script)
    if not getscriptclosure then
        return nil, "getscriptclosure mevcut değil"
    end
    
    local success, closure = pcall(getscriptclosure, script)
    if not success then
        return nil, closure
    end
    
    return closure
end

function ScriptAnalyzer.analyzeScript(script)
    local result = {
        name = script.Name,
        className = script.ClassName,
        path = script:GetFullName(),
        bytecode = nil,
        closure = nil,
        analysis = nil,
        parsedBytecode = nil
    }
    
    -- Bytecode al
    result.bytecode = ScriptAnalyzer.getScriptBytecode(script)
    
    -- Closure al
    result.closure = ScriptAnalyzer.getScriptClosure(script)
    
    -- Closure analiz et
    if result.closure then
        result.analysis = FunctionAnalyzer.analyze(result.closure)
    end
    
    -- Bytecode parse et
    if result.bytecode then
        result.parsedBytecode = BytecodeAnalyzer.parseBytecode(result.bytecode)
    end
    
    return result
end

--[[
    CODE GENERATION (Decompile)
    Bytecode'dan Lua kodu üret
]]

function Decompiler:decompileProto(proto, parsedBytecode, depth)
    depth = depth or 0
    
    if depth > Config.MaxDepth then
        self:emit("-- Max depth reached")
        return
    end
    
    -- Function header
    local params = {}
    for i = 1, proto.numParams do
        local paramName = "arg" .. i
        if proto.locals and proto.locals[i] then
            paramName = proto.locals[i].name
        end
        table.insert(params, paramName)
    end
    
    if proto.isVararg == 1 then
        table.insert(params, "...")
    end
    
    local funcHeader = "function(" .. table.concat(params, ", ") .. ")"
    
    if proto.debugName and proto.debugName ~= "" then
        self:emit("-- Function: " .. proto.debugName)
    end
    
    self:emit(funcHeader)
    self:indent()
    
    -- Constant pool göster (debug)
    if Config.ShowConstantPool and #proto.constants > 0 then
        self:emit("--[[ Constant Pool:")
        for i, const in ipairs(proto.constants) do
            local valStr
            if const.type == "string" then
                valStr = '"' .. tostring(const.value):gsub("\n", "\\n") .. '"'
            elseif const.type == "nil" then
                valStr = "nil"
            elseif const.type == "boolean" then
                valStr = tostring(const.value)
            else
                valStr = tostring(const.value)
            end
            self:emit("    [" .. i .. "] = " .. const.type .. ": " .. valStr)
        end
        self:emit("]]")
        self:emit("")
    end
    
    -- Upvalue info göster (debug)
    if Config.ShowUpvalueInfo and proto.upvalueNames and #proto.upvalueNames > 0 then
        self:emit("-- Upvalues: " .. table.concat(proto.upvalueNames, ", "))
    end
    
    -- Instructions'ı decompile et
    self:decompileInstructions(proto, parsedBytecode)
    
    self:dedent()
    self:emit("end")
end

function Decompiler:decompileInstructions(proto, parsedBytecode)
    local instructions = proto.instructions
    local constants = proto.constants
    local strings = parsedBytecode.strings
    
    -- Register state tracking
    local registers = {}
    for i = 0, proto.maxStackSize do
        registers[i] = self:genVar("r")
    end
    
    -- Local variable isimleri
    if proto.locals then
        for _, loc in ipairs(proto.locals) do
            if loc.reg < proto.maxStackSize then
                registers[loc.reg] = loc.name
            end
        end
    end
    
    local pc = 1
    local pendingStatements = {}
    
    while pc <= #instructions do
        local inst = BytecodeAnalyzer.decodeInstruction(instructions[pc])
        local opname = inst.opname
        local A, B, C = inst.A, inst.B, inst.C
        local Bx, sBx = inst.Bx, inst.sBx
        
        -- Bytecode comment
        if Config.ShowBytecodeComments then
            self:emit(string.format("-- [%d] %s A=%d B=%d C=%d", pc, opname, A, B, C))
        end
        
        -- Opcode'a göre kod üret
        if opname == "LOADNIL" then
            self:emit(registers[A] .. " = nil")
            
        elseif opname == "LOADB" then
            local val = B == 1 and "true" or "false"
            self:emit(registers[A] .. " = " .. val)
            if C ~= 0 then
                pc = pc + C -- Jump
            end
            
        elseif opname == "LOADN" then
            self:emit(registers[A] .. " = " .. tostring(sD))
            
        elseif opname == "LOADK" then
            local const = constants[Bx + 1]
            local valStr = self:constantToString(const)
            self:emit(registers[A] .. " = " .. valStr)
            
        elseif opname == "MOVE" then
            self:emit(registers[A] .. " = " .. registers[B])
            
        elseif opname == "GETGLOBAL" then
            local aux = instructions[pc + 1]
            local nameIdx = bit32.band(aux, 0xFFFFFF)
            local name = strings[nameIdx] or constants[nameIdx] and constants[nameIdx].value or "global_" .. nameIdx
            self:emit(registers[A] .. " = " .. tostring(name))
            pc = pc + 1
            
        elseif opname == "SETGLOBAL" then
            local aux = instructions[pc + 1]
            local nameIdx = bit32.band(aux, 0xFFFFFF)
            local name = strings[nameIdx] or constants[nameIdx] and constants[nameIdx].value or "global_" .. nameIdx
            self:emit(tostring(name) .. " = " .. registers[A])
            pc = pc + 1
            
        elseif opname == "GETUPVAL" then
            local upvalName = proto.upvalueNames and proto.upvalueNames[B + 1] or ("upval_" .. B)
            self:emit(registers[A] .. " = " .. upvalName)
            
        elseif opname == "SETUPVAL" then
            local upvalName = proto.upvalueNames and proto.upvalueNames[B + 1] or ("upval_" .. B)
            self:emit(upvalName .. " = " .. registers[A])
            
        elseif opname == "GETTABLEKS" then
            local aux = instructions[pc + 1]
            local nameIdx = bit32.band(aux, 0xFFFFFF)
            local key = strings[nameIdx] or constants[nameIdx] and constants[nameIdx].value or "key_" .. nameIdx
            self:emit(registers[A] .. " = " .. registers[B] .. "." .. tostring(key))
            pc = pc + 1
            
        elseif opname == "SETTABLEKS" then
            local aux = instructions[pc + 1]
            local nameIdx = bit32.band(aux, 0xFFFFFF)
            local key = strings[nameIdx] or constants[nameIdx] and constants[nameIdx].value or "key_" .. nameIdx
            self:emit(registers[B] .. "." .. tostring(key) .. " = " .. registers[A])
            pc = pc + 1
            
        elseif opname == "GETTABLE" then
            self:emit(registers[A] .. " = " .. registers[B] .. "[" .. registers[C] .. "]")
            
        elseif opname == "SETTABLE" then
            self:emit(registers[B] .. "[" .. registers[C] .. "] = " .. registers[A])
            
        elseif opname == "GETTABLEN" then
            self:emit(registers[A] .. " = " .. registers[B] .. "[" .. (C + 1) .. "]")
            
        elseif opname == "SETTABLEN" then
            self:emit(registers[B] .. "[" .. (C + 1) .. "] = " .. registers[A])
            
        elseif opname == "NEWTABLE" then
            self:emit(registers[A] .. " = {}")
            pc = pc + 1 -- Skip aux
            
        elseif opname == "NAMECALL" then
            local aux = instructions[pc + 1]
            local nameIdx = bit32.band(aux, 0xFFFFFF)
            local methodName = strings[nameIdx] or constants[nameIdx] and constants[nameIdx].value or "method_" .. nameIdx
            self:emit("-- NAMECALL: " .. registers[B] .. ":" .. tostring(methodName) .. "(...)")
            registers[A] = registers[B] .. ":" .. tostring(methodName)
            registers[A + 1] = registers[B]
            pc = pc + 1
            
        elseif opname == "CALL" then
            local nargs = B - 1
            local nrets = C - 1
            
            local args = {}
            for i = 1, nargs do
                table.insert(args, registers[A + i])
            end
            
            local callExpr = registers[A] .. "(" .. table.concat(args, ", ") .. ")"
            
            if nrets == 0 then
                self:emit(callExpr)
            elseif nrets == 1 then
                self:emit(registers[A] .. " = " .. callExpr)
            else
                local rets = {}
                for i = 0, nrets - 1 do
                    table.insert(rets, registers[A + i])
                end
                self:emit(table.concat(rets, ", ") .. " = " .. callExpr)
            end
            
        elseif opname == "RETURN" then
            local nrets = B - 1
            if nrets == 0 then
                self:emit("return")
            else
                local rets = {}
                for i = 0, nrets - 1 do
                    table.insert(rets, registers[A + i])
                end
                self:emit("return " .. table.concat(rets, ", "))
            end
            
        elseif opname == "JUMP" then
            local target = pc + 1 + sBx
            self:emit("-- JUMP to " .. target)
            
        elseif opname == "JUMPIF" then
            local target = pc + 1 + sBx
            self:emit("if " .. registers[A] .. " then goto label_" .. target .. " end")
            
        elseif opname == "JUMPIFNOT" then
            local target = pc + 1 + sBx
            self:emit("if not " .. registers[A] .. " then goto label_" .. target .. " end")
            
        elseif opname == "ADD" then
            self:emit(registers[A] .. " = " .. registers[B] .. " + " .. registers[C])
            
        elseif opname == "SUB" then
            self:emit(registers[A] .. " = " .. registers[B] .. " - " .. registers[C])
            
        elseif opname == "MUL" then
            self:emit(registers[A] .. " = " .. registers[B] .. " * " .. registers[C])
            
        elseif opname == "DIV" then
            self:emit(registers[A] .. " = " .. registers[B] .. " / " .. registers[C])
            
        elseif opname == "MOD" then
            self:emit(registers[A] .. " = " .. registers[B] .. " % " .. registers[C])
            
        elseif opname == "POW" then
            self:emit(registers[A] .. " = " .. registers[B] .. " ^ " .. registers[C])
            
        elseif opname == "CONCAT" then
            local parts = {}
            for i = B, C do
                table.insert(parts, registers[i])
            end
            self:emit(registers[A] .. " = " .. table.concat(parts, " .. "))
            
        elseif opname == "NOT" then
            self:emit(registers[A] .. " = not " .. registers[B])
            
        elseif opname == "MINUS" then
            self:emit(registers[A] .. " = -" .. registers[B])
            
        elseif opname == "LENGTH" then
            self:emit(registers[A] .. " = #" .. registers[B])
            
        elseif opname == "FORNPREP" then
            local target = pc + 1 + sBx
            self:emit("-- FOR NUMERIC PREP, jump to " .. target)
            self:emit("for " .. registers[A + 3] .. " = " .. registers[A] .. ", " .. registers[A + 1] .. ", " .. registers[A + 2] .. " do")
            self:indent()
            
        elseif opname == "FORNLOOP" then
            local target = pc + 1 + sBx
            self:dedent()
            self:emit("end -- FOR NUMERIC END")
            
        elseif opname == "FORGPREP" then
            local target = pc + 1 + sBx
            self:emit("-- FOR GENERIC PREP")
            
        elseif opname == "FORGLOOP" then
            local target = pc + 1 + sBx
            local aux = instructions[pc + 1]
            local nloop = bit32.band(aux, 0xFF)
            self:emit("-- FOR GENERIC LOOP, " .. nloop .. " variables")
            pc = pc + 1
            
        elseif opname == "NEWCLOSURE" then
            local protoIdx = Bx + 1
            self:emit(registers[A] .. " = ")
            if parsedBytecode.protos[protoIdx] then
                self:decompileProto(parsedBytecode.protos[protoIdx], parsedBytecode, (proto._depth or 0) + 1)
            else
                self:emit("function() --[[ Proto " .. protoIdx .. " ]] end")
            end
            
        elseif opname == "GETIMPORT" then
            local aux = instructions[pc + 1]
            self:emit("-- GETIMPORT " .. aux)
            self:emit(registers[A] .. " = import_" .. Bx)
            pc = pc + 1
            
        elseif opname == "FASTCALL" or opname == "FASTCALL1" or opname == "FASTCALL2" then
            -- Fast call builtin fonksiyonları
            self:emit("-- FASTCALL builtin " .. A)
            
        elseif opname == "CAPTURE" then
            self:emit("-- CAPTURE type=" .. A .. " index=" .. B)
            
        elseif opname == "SETLIST" then
            self:emit("-- SETLIST")
            pc = pc + 1 -- Skip aux
            
        elseif opname == "DUPTABLE" then
            self:emit(registers[A] .. " = {} -- DUPTABLE")
            
        elseif opname == "GETVARARGS" then
            if B == 0 then
                self:emit(registers[A] .. " = ...")
            else
                local vars = {}
                for i = 0, B - 2 do
                    table.insert(vars, registers[A + i])
                end
                self:emit(table.concat(vars, ", ") .. " = ...")
            end
            
        elseif opname == "CLOSEUPVALS" then
            self:emit("-- CLOSEUPVALS from " .. A)
            
        else
            self:emit("-- Unknown opcode: " .. opname .. " (" .. inst.opcode .. ")")
        end
        
        pc = pc + 1
    end
end

function Decompiler:constantToString(const)
    if not const then return "nil" end
    
    if const.type == "nil" then
        return "nil"
    elseif const.type == "boolean" then
        return tostring(const.value)
    elseif const.type == "number" then
        return tostring(const.value)
    elseif const.type == "string" then
        return '"' .. tostring(const.value):gsub('\\', '\\\\'):gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\t', '\\t') .. '"'
    elseif const.type == "table" then
        return "{} --[[table template]]"
    elseif const.type == "closure" then
        return "function() end --[[closure " .. tostring(const.value) .. "]]"
    else
        return "nil --[[unknown type: " .. tostring(const.type) .. "]]"
    end
end

-- Ana decompile fonksiyonu
function Decompiler:decompile(input)
    self.output = {}
    self.indentLevel = 0
    self.varCounter = 0
    self.labelCounter = 0
    
    local bytecode, parsedBytecode
    
    -- Input türünü belirle
    if type(input) == "string" then
        -- Raw bytecode
        bytecode = input
        parsedBytecode = BytecodeAnalyzer.parseBytecode(bytecode)
    elseif type(input) == "function" then
        -- Function
        local analysis = FunctionAnalyzer.analyze(input)
        if analysis.bytecode then
            bytecode = analysis.bytecode
            parsedBytecode = BytecodeAnalyzer.parseBytecode(bytecode)
        else
            -- Bytecode yok, sadece analiz bilgisiyle çalış
            return self:decompileFunctionAnalysis(analysis)
        end
    elseif typeof and typeof(input) == "Instance" then
        -- Script instance
        local scriptAnalysis = ScriptAnalyzer.analyzeScript(input)
        if scriptAnalysis.bytecode then
            bytecode = scriptAnalysis.bytecode
            parsedBytecode = scriptAnalysis.parsedBytecode or BytecodeAnalyzer.parseBytecode(bytecode)
        else
            return "-- Could not get bytecode for " .. input:GetFullName()
        end
    end
    
    if not parsedBytecode then
        return "-- Failed to parse bytecode"
    end
    
    -- Header
    self:emitRaw("--[[")
    self:emitRaw("    Decompiled by Luau Decompiler")
    self:emitRaw("    Bytecode Version: " .. (parsedBytecode.version or "unknown"))
    self:emitRaw("    String Count: " .. (parsedBytecode.stringCount or 0))
    self:emitRaw("    Proto Count: " .. (parsedBytecode.protoCount or 0))
    self:emitRaw("]]")
    self:emitRaw("")
    
    -- Main proto'yu decompile et
    if parsedBytecode.protos and parsedBytecode.mainProto then
        local mainProto = parsedBytecode.protos[parsedBytecode.mainProto]
        if mainProto then
            mainProto._depth = 0
            self:decompileProto(mainProto, parsedBytecode, 0)
        end
    end
    
    return table.concat(self.output, "\n")
end

-- Function analysis'dan decompile (bytecode yoksa)
function Decompiler:decompileFunctionAnalysis(analysis)
    self.output = {}
    
    self:emitRaw("--[[")
    self:emitRaw("    Function Analysis (No Bytecode)")
    self:emitRaw("]]")
    self:emitRaw("")
    
    -- Constants
    if analysis.constants and next(analysis.constants) then
        self:emit("-- Constants:")
        for idx, val in pairs(analysis.constants) do
            local valStr
            if type(val) == "string" then
                valStr = '"' .. val:gsub("\n", "\\n") .. '"'
            elseif type(val) == "function" then
                valStr = "function"
            else
                valStr = tostring(val)
            end
            self:emit("--   [" .. idx .. "] = " .. valStr)
        end
        self:emitRaw("")
    end
    
    -- Upvalues
    if analysis.upvalues and next(analysis.upvalues) then
        self:emit("-- Upvalues:")
        for idx, val in pairs(analysis.upvalues) do
            self:emit("--   [" .. idx .. "] = " .. type(val) .. ": " .. tostring(val))
        end
        self:emitRaw("")
    end
    
    -- Nested functions
    if analysis.protos and #analysis.protos > 0 then
        self:emit("-- Nested Functions: " .. #analysis.protos)
        for i, proto in ipairs(analysis.protos) do
            self:emit("-- Proto " .. i .. ": " .. tostring(proto))
        end
        self:emitRaw("")
    end
    
    -- Info
    if analysis.info then
        self:emit("-- Debug Info:")
        for k, v in pairs(analysis.info) do
            self:emit("--   " .. k .. " = " .. tostring(v))
        end
    end
    
    return table.concat(self.output, "\n")
end

--[[
    GC SCANNER
    getgc() ile memory'deki fonksiyonları tara
]]

local GCScanner = {}

function GCScanner.scanFunctions(filter)
    if not getgc then
        return {}, "getgc mevcut değil"
    end
    
    local results = {}
    local gc = getgc(true)
    
    for _, obj in ipairs(gc) do
        if type(obj) == "function" then
            local shouldInclude = true
            
            if filter then
                if filter.hasConstant then
                    local constants = debug.getconstants and debug.getconstants(obj) or {}
                    shouldInclude = false
                    for _, c in pairs(constants) do
                        if c == filter.hasConstant then
                            shouldInclude = true
                            break
                        end
                    end
                end
                
                if filter.hasUpvalue and shouldInclude then
                    local upvalues = debug.getupvalues and debug.getupvalues(obj) or {}
                    shouldInclude = false
                    for _, u in pairs(upvalues) do
                        if u == filter.hasUpvalue then
                            shouldInclude = true
                            break
                        end
                    end
                end
                
                if filter.name and shouldInclude then
                    local info = debug.getinfo and debug.getinfo(obj) or {}
                    shouldInclude = info.name and info.name:find(filter.name)
                end
            end
            
            if shouldInclude then
                table.insert(results, obj)
            end
        end
    end
    
    return results
end

function GCScanner.findByConstant(searchValue)
    return GCScanner.scanFunctions({hasConstant = searchValue})
end

function GCScanner.findByUpvalue(searchValue)
    return GCScanner.scanFunctions({hasUpvalue = searchValue})
end

--[[
    ENVIRONMENT SCANNER
    Script environment'larını tara
]]

local EnvironmentScanner = {}

function EnvironmentScanner.getScriptEnvironment(script)
    if not getsenv then
        return nil, "getsenv mevcut değil"
    end
    
    local success, env = pcall(getsenv, script)
    if not success then
        return nil, env
    end
    
    return env
end

function EnvironmentScanner.scanAllScripts()
    local results = {}
    
    local function scanContainer(container)
        for _, child in ipairs(container:GetChildren()) do
            if child:IsA("LocalScript") or child:IsA("ModuleScript") then
                local env = EnvironmentScanner.getScriptEnvironment(child)
                if env then
                    table.insert(results, {
                        script = child,
                        environment = env
                    })
                end
            end
            pcall(scanContainer, child)
        end
    end
    
    pcall(scanContainer, game)
    
    return results
end

--[[
    ANA API
]]

local DecompilerAPI = {
    Decompiler = Decompiler,
    BytecodeAnalyzer = BytecodeAnalyzer,
    FunctionAnalyzer = FunctionAnalyzer,
    ScriptAnalyzer = ScriptAnalyzer,
    GCScanner = GCScanner,
    EnvironmentScanner = EnvironmentScanner,
    Config = Config
}

-- Kolay kullanım fonksiyonları
function DecompilerAPI.decompile(input)
    local dec = Decompiler.new()
    return dec:decompile(input)
end

function DecompilerAPI.analyze(func)
    return FunctionAnalyzer.analyze(func)
end

function DecompilerAPI.analyzeScript(script)
    return ScriptAnalyzer.analyzeScript(script)
end

function DecompilerAPI.scanGC(filter)
    return GCScanner.scanFunctions(filter)
end

function DecompilerAPI.getScriptEnv(script)
    return EnvironmentScanner.getScriptEnvironment(script)
end

-- Bytecode dump (hex görünümü)
function DecompilerAPI.hexDump(bytecode, bytesPerLine)
    bytesPerLine = bytesPerLine or 16
    local lines = {}
    
    for i = 1, #bytecode, bytesPerLine do
        local hex = {}
        local ascii = {}
        
        for j = 0, bytesPerLine - 1 do
            local idx = i + j
            if idx <= #bytecode then
                local byte = string.byte(bytecode, idx)
                table.insert(hex, string.format("%02X", byte))
                if byte >= 32 and byte <= 126 then
                    table.insert(ascii, string.char(byte))
                else
                    table.insert(ascii, ".")
                end
            else
                table.insert(hex, "  ")
                table.insert(ascii, " ")
            end
        end
        
        table.insert(lines, string.format("%08X  %-48s  %s", i - 1, table.concat(hex, " "), table.concat(ascii)))
    end
    
    return table.concat(lines, "\n")
end

-- Instruction disassembler
function DecompilerAPI.disassemble(bytecode)
    local parsed = BytecodeAnalyzer.parseBytecode(bytecode)
    if not parsed then
        return "Failed to parse bytecode"
    end
    
    local lines = {}
    table.insert(lines, "=== LUAU DISASSEMBLY ===")
    table.insert(lines, "Version: " .. parsed.version)
    table.insert(lines, "Strings: " .. parsed.stringCount)
    table.insert(lines, "Protos: " .. parsed.protoCount)
    table.insert(lines, "")
    
    -- String table
    table.insert(lines, "--- STRING TABLE ---")
    for i, str in ipairs(parsed.strings) do
        table.insert(lines, string.format("[%d] = %q", i, str))
    end
    table.insert(lines, "")
    
    -- Her proto
    for protoIdx, proto in ipairs(parsed.protos) do
        table.insert(lines, string.format("--- PROTO %d: %s ---", protoIdx, proto.debugName or "(anonymous)"))
        table.insert(lines, string.format("Stack: %d, Params: %d, Upvalues: %d, Vararg: %s",
            proto.maxStackSize, proto.numParams, proto.numUpvalues, proto.isVararg == 1 and "yes" or "no"))
        
        -- Constants
        if #proto.constants > 0 then
            table.insert(lines, "Constants:")
            for i, const in ipairs(proto.constants) do
                table.insert(lines, string.format("  [%d] %s: %s", i, const.type, tostring(const.value)))
            end
        end
        
        -- Instructions
        table.insert(lines, "Instructions:")
        for pc, inst in ipairs(proto.instructions) do
            local decoded = BytecodeAnalyzer.decodeInstruction(inst)
            local line = proto.lineInfo and proto.lineInfo[pc]
            local lineStr = line and string.format("L%d", line) or ""
            table.insert(lines, string.format("  %04d %6s  %-12s A=%-3d B=%-3d C=%-3d  ; %08X",
                pc, lineStr, decoded.opname, decoded.A, decoded.B, decoded.C, inst))
        end
        
        table.insert(lines, "")
    end
    
    return table.concat(lines, "\n")
end

return DecompilerAPI
